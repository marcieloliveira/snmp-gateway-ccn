/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

//by Marciel 
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ccnMIB.h"

/** Initializes the ccnMIB - ccnSysten and ccndStatus module */
void
init_ccnMIB(void)
{
	/** ccnSystem */
	const oid ccnsysName_oid[] = { 1,3,6,1,2,1,100,1,1 };
	const oid ccnsysUptime_oid[] = { 1,3,6,1,2,1,100,1,2 };
	const oid ccnsysLoads_oid[] = { 1,3,6,1,2,1,100,1,3 };
	const oid ccnsysTotalram_oid[] = { 1,3,6,1,2,1,100,1,4 };
	const oid ccnsysFreeram_oid[] = { 1,3,6,1,2,1,100,1,5 };
	const oid ccnsysSharedram_oid[] = { 1,3,6,1,2,1,100,1,6 };
	const oid ccnsysBufferram_oid[] = { 1,3,6,1,2,1,100,1,7 };
	const oid ccnsysTotalswap_oid[] = { 1,3,6,1,2,1,100,1,8 };
	const oid ccnsysFreeswap_oid[] = { 1,3,6,1,2,1,100,1,9 };
	const oid ccnsysProcs_oid[] = { 1,3,6,1,2,1,100,1,10 };
	const oid ccnsysTotalhigh_oid[] = { 1,3,6,1,2,1,100,1,11 };
	const oid ccnsysFreehigh_oid[] = { 1,3,6,1,2,1,100,1,12 };
	const oid ccnsysMemunit_oid[] = { 1,3,6,1,2,1,100,1,13 };
	const oid ccnsysCharf_oid[] = { 1,3,6,1,2,1,100,1,14 };

	/** ccndStatus/contentItems */
    const oid ciAccessioned_oid[] = { 1,3,6,1,2,1,100,2,1,1 };
    const oid ciDuplicate_oid[] = { 1,3,6,1,2,1,100,2,1,2 };
    const oid ciSent_oid[] = { 1,3,6,1,2,1,100,2,1,3 };
    const oid ciSparse_oid[] = { 1,3,6,1,2,1,100,2,1,4 };
    const oid ciStale_oid[] = { 1,3,6,1,2,1,100,2,1,5 };
    const oid ciStored_oid[] = { 1,3,6,1,2,1,100,2,1,6 };
    const oid ciHost_oid[] = { 1,3,6,1,2,1,100,2,1,7 };
    const oid ciTimestamp_oid[] = { 1,3,6,1,2,1,100,2,1,8 };

	/** ccndStatus/interests */
    const oid iNames_oid[] = { 1,3,6,1,2,1,100,2,2,1 };
    const oid iNoted_oid[] = { 1,3,6,1,2,1,100,2,2,2 };
    const oid iPending_oid[] = { 1,3,6,1,2,1,100,2,2,3 };
    const oid iPropagating_oid[] = { 1,3,6,1,2,1,100,2,2,4 };
    const oid iHost_oid[] = { 1,3,6,1,2,1,100,2,2,5 };
    const oid iTimestamp_oid[] = { 1,3,6,1,2,1,100,2,2,6 };

	/** ccndStatus/interestTotals */
    const oid itAccepted_oid[] = { 1,3,6,1,2,1,100,2,3,1 };
    const oid itDropped_oid[] = { 1,3,6,1,2,1,100,2,3,2 };
    const oid itSent_oid[] = { 1,3,6,1,2,1,100,2,3,3 };
    const oid itStuffed_oid[] = { 1,3,6,1,2,1,100,2,3,4 };
    const oid itHost_oid[] = { 1,3,6,1,2,1,100,2,3,5 };
    const oid itTimestamp_oid[] = { 1,3,6,1,2,1,100,2,3,6 };

	/** ccndStatus/faces */
    const oid fFace0_oid[] = { 1,3,6,1,2,1,100,2,4,1 };
    const oid fFlags0_oid[] = { 1,3,6,1,2,1,100,2,4,2 };
    const oid fLocal0_oid[] = { 1,3,6,1,2,1,100,2,4,3 };
    const oid fPending0_oid[] = { 1,3,6,1,2,1,100,2,4,4 };
    const oid fRemote0_oid[] = { 1,3,6,1,2,1,100,2,4,5 };
    const oid fHost0_oid[] = { 1,3,6,1,2,1,100,2,4,6 };
    const oid fTimestamp0_oid[] = { 1,3,6,1,2,1,100,2,4,7 };

    const oid fFace1_oid[] = { 1,3,6,1,2,1,100,2,4,8 };
    const oid fFlags1_oid[] = { 1,3,6,1,2,1,100,2,4,9 };
    const oid fLocal1_oid[] = { 1,3,6,1,2,1,100,2,4,10 };
    const oid fPending1_oid[] = { 1,3,6,1,2,1,100,2,4,11 };
    const oid fRemote1_oid[] = { 1,3,6,1,2,1,100,2,4,12 };
    const oid fHost1_oid[] = { 1,3,6,1,2,1,100,2,4,13 };
    const oid fTimestamp1_oid[] = { 1,3,6,1,2,1,100,2,4,14 };

    const oid fFace2_oid[] = { 1,3,6,1,2,1,100,2,4,15 };
    const oid fFlags2_oid[] = { 1,3,6,1,2,1,100,2,4,16};
    const oid fLocal2_oid[] = { 1,3,6,1,2,1,100,2,4,17 };
    const oid fPending2_oid[] = { 1,3,6,1,2,1,100,2,4,18 };
    const oid fRemote2_oid[] = { 1,3,6,1,2,1,100,2,4,19 };
    const oid fHost2_oid[] = { 1,3,6,1,2,1,100,2,4,20 };
    const oid fTimestamp2_oid[] = { 1,3,6,1,2,1,100,2,4,21 };

    const oid fFace3_oid[] = { 1,3,6,1,2,1,100,2,4,22 };
    const oid fFlags3_oid[] = { 1,3,6,1,2,1,100,2,4,23 };
    const oid fLocal3_oid[] = { 1,3,6,1,2,1,100,2,4,24 };
    const oid fPending3_oid[] = { 1,3,6,1,2,1,100,2,4,25 };
    const oid fRemote3_oid[] = { 1,3,6,1,2,1,100,2,4,26 };
    const oid fHost3_oid[] = { 1,3,6,1,2,1,100,2,4,27 };
    const oid fTimestamp3_oid[] = { 1,3,6,1,2,1,100,2,4,28 };

    const oid fFace4_oid[] = { 1,3,6,1,2,1,100,2,4,29 };
    const oid fFlags4_oid[] = { 1,3,6,1,2,1,100,2,4,30 };
    const oid fLocal4_oid[] = { 1,3,6,1,2,1,100,2,4,31 };
    const oid fPending4_oid[] = { 1,3,6,1,2,1,100,2,4,32 };
    const oid fRemote4_oid[] = { 1,3,6,1,2,1,100,2,4,33 };
    const oid fHost4_oid[] = { 1,3,6,1,2,1,100,2,4,34 };
    const oid fTimestamp4_oid[] = { 1,3,6,1,2,1,100,2,4,35 };

    const oid fFace5_oid[] = { 1,3,6,1,2,1,100,2,4,36 };
    const oid fFlags5_oid[] = { 1,3,6,1,2,1,100,2,4,37 };
    const oid fLocal5_oid[] = { 1,3,6,1,2,1,100,2,4,38 };
    const oid fPending5_oid[] = { 1,3,6,1,2,1,100,2,4,39 };
    const oid fRemote5_oid[] = { 1,3,6,1,2,1,100,2,4,40 };
    const oid fHost5_oid[] = { 1,3,6,1,2,1,100,2,4,41 };
    const oid fTimestamp5_oid[] = { 1,3,6,1,2,1,100,2,4,42 };

    const oid fFace6_oid[] = { 1,3,6,1,2,1,100,2,4,43 };
    const oid fFlags6_oid[] = { 1,3,6,1,2,1,100,2,4,44 };
    const oid fLocal6_oid[] = { 1,3,6,1,2,1,100,2,4,45 };
    const oid fPending6_oid[] = { 1,3,6,1,2,1,100,2,4,46 };
    const oid fRemote6_oid[] = { 1,3,6,1,2,1,100,2,4,47 };
    const oid fHost6_oid[] = { 1,3,6,1,2,1,100,2,4,48 };
    const oid fTimestamp6_oid[] = { 1,3,6,1,2,1,100,2,4,49 };

    const oid fFace7_oid[] = { 1,3,6,1,2,1,100,2,4,50 };
    const oid fFlags7_oid[] = { 1,3,6,1,2,1,100,2,4,51 };
    const oid fLocal7_oid[] = { 1,3,6,1,2,1,100,2,4,52 };
    const oid fPending7_oid[] = { 1,3,6,1,2,1,100,2,4,53 };
    const oid fRemote7_oid[] = { 1,3,6,1,2,1,100,2,4,54 };
    const oid fHost7_oid[] = { 1,3,6,1,2,1,100,2,4,55 };
    const oid fTimestamp7_oid[] = { 1,3,6,1,2,1,100,2,4,56 };

    const oid fFace8_oid[] = { 1,3,6,1,2,1,100,2,4,57 };
    const oid fFlags8_oid[] = { 1,3,6,1,2,1,100,2,4,58 };
    const oid fLocal8_oid[] = { 1,3,6,1,2,1,100,2,4,59 };
    const oid fPending8_oid[] = { 1,3,6,1,2,1,100,2,4,60 };
    const oid fRemote8_oid[] = { 1,3,6,1,2,1,100,2,4,61 };
    const oid fHost8_oid[] = { 1,3,6,1,2,1,100,2,4,62 };
    const oid fTimestamp8_oid[] = { 1,3,6,1,2,1,100,2,4,63 };

    const oid fFace9_oid[] = { 1,3,6,1,2,1,100,2,4,64 };
    const oid fFlags9_oid[] = { 1,3,6,1,2,1,100,2,4,65 };
    const oid fLocal9_oid[] = { 1,3,6,1,2,1,100,2,4,66 };
    const oid fPending9_oid[] = { 1,3,6,1,2,1,100,2,4,67 };
    const oid fRemote9_oid[] = { 1,3,6,1,2,1,100,2,4,68 };
    const oid fHost9_oid[] = { 1,3,6,1,2,1,100,2,4,69 };
    const oid fTimestamp9_oid[] = { 1,3,6,1,2,1,100,2,4,70 };

    const oid fFace10_oid[] = { 1,3,6,1,2,1,100,2,4,71 };
    const oid fFlags10_oid[] = { 1,3,6,1,2,1,100,2,4,72 };
    const oid fLocal10_oid[] = { 1,3,6,1,2,1,100,2,4,73 };
    const oid fPending10_oid[] = { 1,3,6,1,2,1,100,2,4,74 };
    const oid fRemote10_oid[] = { 1,3,6,1,2,1,100,2,4,75 };
    const oid fHost10_oid[] = { 1,3,6,1,2,1,100,2,4,76 };
    const oid fTimestamp10_oid[] = { 1,3,6,1,2,1,100,2,4,77 };

    const oid fFace11_oid[] = { 1,3,6,1,2,1,100,2,4,78 };
    const oid fFlags11_oid[] = { 1,3,6,1,2,1,100,2,4,79 };
    const oid fLocal11_oid[] = { 1,3,6,1,2,1,100,2,4,80 };
    const oid fPending11_oid[] = { 1,3,6,1,2,1,100,2,4,81 };
    const oid fRemote11_oid[] = { 1,3,6,1,2,1,100,2,4,82 };
    const oid fHost11_oid[] = { 1,3,6,1,2,1,100,2,4,83 };
    const oid fTimestamp11_oid[] = { 1,3,6,1,2,1,100,2,4,84 };

    const oid fFace12_oid[] = { 1,3,6,1,2,1,100,2,4,85 };
    const oid fFlags12_oid[] = { 1,3,6,1,2,1,100,2,4,86 };
    const oid fLocal12_oid[] = { 1,3,6,1,2,1,100,2,4,87 };
    const oid fPending12_oid[] = { 1,3,6,1,2,1,100,2,4,88 };
    const oid fRemote12_oid[] = { 1,3,6,1,2,1,100,2,4,89 };
    const oid fHost12_oid[] = { 1,3,6,1,2,1,100,2,4,90 };
    const oid fTimestamp12_oid[] = { 1,3,6,1,2,1,100,2,4,91 };

    const oid fFace13_oid[] = { 1,3,6,1,2,1,100,2,4,92 };
    const oid fFlags13_oid[] = { 1,3,6,1,2,1,100,2,4,93 };
    const oid fLocal13_oid[] = { 1,3,6,1,2,1,100,2,4,94 };
    const oid fPending13_oid[] = { 1,3,6,1,2,1,100,2,4,95 };
    const oid fRemote13_oid[] = { 1,3,6,1,2,1,100,2,4,96 };
    const oid fHost13_oid[] = { 1,3,6,1,2,1,100,2,4,97 };
    const oid fTimestamp13_oid[] = { 1,3,6,1,2,1,100,2,4,98 };

	/** ccndStatus/faceActivityRates */
    const oid farFace0_oid[] = { 1,3,6,1,2,1,100,2,5,1 };
    const oid farBytesIn0_oid[] = { 1,3,6,1,2,1,100,2,5,2 };
    const oid farBytesOut0_oid[] = { 1,3,6,1,2,1,100,2,5,3 };
    const oid farReceivedData0_oid[] = { 1,3,6,1,2,1,100,2,5,4 };
    const oid farSentData0_oid[] = { 1,3,6,1,2,1,100,2,5,5 };
    const oid farInterestsReceived0_oid[] = { 1,3,6,1,2,1,100,2,5,6 };
    const oid farInterestsSent0_oid[] = { 1,3,6,1,2,1,100,2,5,7 };
    const oid farHost0_oid[] = { 1,3,6,1,2,1,100,2,5,8 };
    const oid farTimestamp0_oid[] = { 1,3,6,1,2,1,100,2,5,9 };

    const oid farFace1_oid[] = { 1,3,6,1,2,1,100,2,5,10 };
    const oid farBytesIn1_oid[] = { 1,3,6,1,2,1,100,2,5,11 };
    const oid farBytesOut1_oid[] = { 1,3,6,1,2,1,100,2,5,12 };
    const oid farReceivedData1_oid[] = { 1,3,6,1,2,1,100,2,5,13 };
    const oid farSentData1_oid[] = { 1,3,6,1,2,1,100,2,5,14 };
    const oid farInterestsReceived1_oid[] = { 1,3,6,1,2,1,100,2,5,15 };
    const oid farInterestsSent1_oid[] = { 1,3,6,1,2,1,100,2,5,16 };
    const oid farHost1_oid[] = { 1,3,6,1,2,1,100,2,5,17 };
    const oid farTimestamp1_oid[] = { 1,3,6,1,2,1,100,2,5,18 };

    const oid farFace2_oid[] = { 1,3,6,1,2,1,100,2,5,19 };
    const oid farBytesIn2_oid[] = { 1,3,6,1,2,1,100,2,5,20 };
    const oid farBytesOut2_oid[] = { 1,3,6,1,2,1,100,2,5,21 };
    const oid farReceivedData2_oid[] = { 1,3,6,1,2,1,100,2,5,22 };
    const oid farSentData2_oid[] = { 1,3,6,1,2,1,100,2,5,23 };
    const oid farInterestsReceived2_oid[] = { 1,3,6,1,2,1,100,2,5,24 };
    const oid farInterestsSent2_oid[] = { 1,3,6,1,2,1,100,2,5,25 };
    const oid farHost2_oid[] = { 1,3,6,1,2,1,100,2,5,26 };
    const oid farTimestamp2_oid[] = { 1,3,6,1,2,1,100,2,5,27 };

    const oid farFace3_oid[] = { 1,3,6,1,2,1,100,2,5,28 };
    const oid farBytesIn3_oid[] = { 1,3,6,1,2,1,100,2,5,29 };
    const oid farBytesOut3_oid[] = { 1,3,6,1,2,1,100,2,5,30 };
    const oid farReceivedData3_oid[] = { 1,3,6,1,2,1,100,2,5,31 };
    const oid farSentData3_oid[] = { 1,3,6,1,2,1,100,2,5,32 };
    const oid farInterestsReceived3_oid[] = { 1,3,6,1,2,1,100,2,5,33 };
    const oid farInterestsSent3_oid[] = { 1,3,6,1,2,1,100,2,5,34 };
    const oid farHost3_oid[] = { 1,3,6,1,2,1,100,2,5,35 };
    const oid farTimestamp3_oid[] = { 1,3,6,1,2,1,100,2,5,36 };

    const oid farFace4_oid[] = { 1,3,6,1,2,1,100,2,5,37 };
    const oid farBytesIn4_oid[] = { 1,3,6,1,2,1,100,2,5,38 };
    const oid farBytesOut4_oid[] = { 1,3,6,1,2,1,100,2,5,39 };
    const oid farReceivedData4_oid[] = { 1,3,6,1,2,1,100,2,5,40 };
    const oid farSentData4_oid[] = { 1,3,6,1,2,1,100,2,5,41 };
    const oid farInterestsReceived4_oid[] = { 1,3,6,1,2,1,100,2,5,42 };
    const oid farInterestsSent4_oid[] = { 1,3,6,1,2,1,100,2,5,43 };
    const oid farHost4_oid[] = { 1,3,6,1,2,1,100,2,5,44 };
    const oid farTimestamp4_oid[] = { 1,3,6,1,2,1,100,2,5,45 };

    const oid farFace5_oid[] = { 1,3,6,1,2,1,100,2,5,46 };
    const oid farBytesIn5_oid[] = { 1,3,6,1,2,1,100,2,5,47 };
    const oid farBytesOut5_oid[] = { 1,3,6,1,2,1,100,2,5,48 };
    const oid farReceivedData5_oid[] = { 1,3,6,1,2,1,100,2,5,49 };
    const oid farSentData5_oid[] = { 1,3,6,1,2,1,100,2,5,50 };
    const oid farInterestsReceived5_oid[] = { 1,3,6,1,2,1,100,2,5,51 };
    const oid farInterestsSent5_oid[] = { 1,3,6,1,2,1,100,2,5,52 };
    const oid farHost5_oid[] = { 1,3,6,1,2,1,100,2,5,53 };
    const oid farTimestamp5_oid[] = { 1,3,6,1,2,1,100,2,5,54 };

    const oid farFace6_oid[] = { 1,3,6,1,2,1,100,2,5,55 };
    const oid farBytesIn6_oid[] = { 1,3,6,1,2,1,100,2,5,56 };
    const oid farBytesOut6_oid[] = { 1,3,6,1,2,1,100,2,5,57 };
    const oid farReceivedData6_oid[] = { 1,3,6,1,2,1,100,2,5,58 };
    const oid farSentData6_oid[] = { 1,3,6,1,2,1,100,2,5,59 };
    const oid farInterestsReceived6_oid[] = { 1,3,6,1,2,1,100,2,5,60 };
    const oid farInterestsSent6_oid[] = { 1,3,6,1,2,1,100,2,5,61 };
    const oid farHost6_oid[] = { 1,3,6,1,2,1,100,2,5,62 };
    const oid farTimestamp6_oid[] = { 1,3,6,1,2,1,100,2,5,63 };

    const oid farFace7_oid[] = { 1,3,6,1,2,1,100,2,5,64 };
    const oid farBytesIn7_oid[] = { 1,3,6,1,2,1,100,2,5,65 };
    const oid farBytesOut7_oid[] = { 1,3,6,1,2,1,100,2,5,66 };
    const oid farReceivedData7_oid[] = { 1,3,6,1,2,1,100,2,5,67 };
    const oid farSentData7_oid[] = { 1,3,6,1,2,1,100,2,5,68 };
    const oid farInterestsReceived7_oid[] = { 1,3,6,1,2,1,100,2,5,69 };
    const oid farInterestsSent7_oid[] = { 1,3,6,1,2,1,100,2,5,70 };
    const oid farHost7_oid[] = { 1,3,6,1,2,1,100,2,5,71 };
    const oid farTimestamp7_oid[] = { 1,3,6,1,2,1,100,2,5,72 };

    const oid farFace8_oid[] = { 1,3,6,1,2,1,100,2,5,73 };
    const oid farBytesIn8_oid[] = { 1,3,6,1,2,1,100,2,5,74 };
    const oid farBytesOut8_oid[] = { 1,3,6,1,2,1,100,2,5,75 };
    const oid farReceivedData8_oid[] = { 1,3,6,1,2,1,100,2,5,76 };
    const oid farSentData8_oid[] = { 1,3,6,1,2,1,100,2,5,77 };
    const oid farInterestsReceived8_oid[] = { 1,3,6,1,2,1,100,2,5,78 };
    const oid farInterestsSent8_oid[] = { 1,3,6,1,2,1,100,2,5,79 };
    const oid farHost8_oid[] = { 1,3,6,1,2,1,100,2,5,80 };
    const oid farTimestamp8_oid[] = { 1,3,6,1,2,1,100,2,5,81 };

	/** ccndStatus/forwarding */
    const oid fwFace0_oid[] = { 1,3,6,1,2,1,100,2,6,1 };
    const oid fwFlags0_oid[] = { 1,3,6,1,2,1,100,2,6,2 };
    const oid fwPath0_oid[] = { 1,3,6,1,2,1,100,2,6,3 };
    const oid fwExpires0_oid[] = { 1,3,6,1,2,1,100,2,6,4 };
    const oid fwHost0_oid[] = { 1,3,6,1,2,1,100,2,6,5 };
    const oid fwTimestamp0_oid[] = { 1,3,6,1,2,1,100,2,6,6 };

    const oid fwFace1_oid[] = { 1,3,6,1,2,1,100,2,6,7 };
    const oid fwFlags1_oid[] = { 1,3,6,1,2,1,100,2,6,8 };
    const oid fwPath1_oid[] = { 1,3,6,1,2,1,100,2,6,9 };
    const oid fwExpires1_oid[] = { 1,3,6,1,2,1,100,2,6,10 };
    const oid fwHost1_oid[] = { 1,3,6,1,2,1,100,2,6,11 };
    const oid fwTimestamp1_oid[] = { 1,3,6,1,2,1,100,2,6,12 };

    const oid fwFace2_oid[] = { 1,3,6,1,2,1,100,2,6,13 };
    const oid fwFlags2_oid[] = { 1,3,6,1,2,1,100,2,6,14 };
    const oid fwPath2_oid[] = { 1,3,6,1,2,1,100,2,6,15 };
    const oid fwExpires2_oid[] = { 1,3,6,1,2,1,100,2,6,16 };
    const oid fwHost2_oid[] = { 1,3,6,1,2,1,100,2,6,17 };
    const oid fwTimestamp2_oid[] = { 1,3,6,1,2,1,100,2,6,18 };

    const oid fwFace3_oid[] = { 1,3,6,1,2,1,100,2,6,19 };
    const oid fwFlags3_oid[] = { 1,3,6,1,2,1,100,2,6,20 };
    const oid fwPath3_oid[] = { 1,3,6,1,2,1,100,2,6,21 };
    const oid fwExpires3_oid[] = { 1,3,6,1,2,1,100,2,6,22 };
    const oid fwHost3_oid[] = { 1,3,6,1,2,1,100,2,6,23 };
    const oid fwTimestamp3_oid[] = { 1,3,6,1,2,1,100,2,6,24 };

    const oid fwFace4_oid[] = { 1,3,6,1,2,1,100,2,6,25 };
    const oid fwFlags4_oid[] = { 1,3,6,1,2,1,100,2,6,26 };
    const oid fwPath4_oid[] = { 1,3,6,1,2,1,100,2,6,27 };
    const oid fwExpires4_oid[] = { 1,3,6,1,2,1,100,2,6,28 };
    const oid fwHost4_oid[] = { 1,3,6,1,2,1,100,2,6,29 };
    const oid fwTimestamp4_oid[] = { 1,3,6,1,2,1,100,2,6,30 };

    const oid fwFace5_oid[] = { 1,3,6,1,2,1,100,2,6,31 };
    const oid fwFlags5_oid[] = { 1,3,6,1,2,1,100,2,6,32 };
    const oid fwPath5_oid[] = { 1,3,6,1,2,1,100,2,6,33 };
    const oid fwExpires5_oid[] = { 1,3,6,1,2,1,100,2,6,34 };
    const oid fwHost5_oid[] = { 1,3,6,1,2,1,100,2,6,35 };
    const oid fwTimestamp5_oid[] = { 1,3,6,1,2,1,100,2,6,36 };

    const oid fwFace6_oid[] = { 1,3,6,1,2,1,100,2,6,37 };
    const oid fwFlags6_oid[] = { 1,3,6,1,2,1,100,2,6,38 };
    const oid fwPath6_oid[] = { 1,3,6,1,2,1,100,2,6,39 };
    const oid fwExpires6_oid[] = { 1,3,6,1,2,1,100,2,6,40 };
    const oid fwHost6_oid[] = { 1,3,6,1,2,1,100,2,6,41 };
    const oid fwTimestamp6_oid[] = { 1,3,6,1,2,1,100,2,6,42 };

    const oid fwFace7_oid[] = { 1,3,6,1,2,1,100,2,6,43 };
    const oid fwFlags7_oid[] = { 1,3,6,1,2,1,100,2,6,44 };
    const oid fwPath7_oid[] = { 1,3,6,1,2,1,100,2,6,45 };
    const oid fwExpires7_oid[] = { 1,3,6,1,2,1,100,2,6,46 };
    const oid fwHost7_oid[] = { 1,3,6,1,2,1,100,2,6,47 };
    const oid fwTimestamp7_oid[] = { 1,3,6,1,2,1,100,2,6,48 };

    const oid fwFace8_oid[] = { 1,3,6,1,2,1,100,2,6,49 };
    const oid fwFlags8_oid[] = { 1,3,6,1,2,1,100,2,6,50 };
    const oid fwPath8_oid[] = { 1,3,6,1,2,1,100,2,6,51 };
    const oid fwExpires8_oid[] = { 1,3,6,1,2,1,100,2,6,52 };
    const oid fwHost8_oid[] = { 1,3,6,1,2,1,100,2,6,53 };
    const oid fwTimestamp8_oid[] = { 1,3,6,1,2,1,100,2,6,54 };

    const oid fwFace9_oid[] = { 1,3,6,1,2,1,100,2,6,55 };
    const oid fwFlags9_oid[] = { 1,3,6,1,2,1,100,2,6,56 };
    const oid fwPath9_oid[] = { 1,3,6,1,2,1,100,2,6,57 };
    const oid fwExpires9_oid[] = { 1,3,6,1,2,1,100,2,6,58 };
    const oid fwHost9_oid[] = { 1,3,6,1,2,1,100,2,6,59 };
    const oid fwTimestamp9_oid[] = { 1,3,6,1,2,1,100,2,6,60 };

    const oid fwFace10_oid[] = { 1,3,6,1,2,1,100,2,6,61 };
    const oid fwFlags10_oid[] = { 1,3,6,1,2,1,100,2,6,62 };
    const oid fwPath10_oid[] = { 1,3,6,1,2,1,100,2,6,63 };
    const oid fwExpires10_oid[] = { 1,3,6,1,2,1,100,2,6,64 };
    const oid fwHost10_oid[] = { 1,3,6,1,2,1,100,2,6,65 };
    const oid fwTimestamp10_oid[] = { 1,3,6,1,2,1,100,2,6,66 };

    netsnmp_handler_registration *reg;

    DEBUGMSGTL(("ccnMIB", "Initializing\n"));

  /** Registro dos OIDs de ccnSystem */
  netsnmp_register_scalar(
               netsnmp_create_handler_registration("ccnsysName", handle_ccnsysName,
            		   	   	     ccnsysName_oid, OID_LENGTH(ccnsysName_oid),
                                 HANDLER_CAN_RONLY
             ));

  netsnmp_register_scalar(
            netsnmp_create_handler_registration("ccnsysUptime", handle_ccnsysUptime,
            					 ccnsysUptime_oid, OID_LENGTH(ccnsysUptime_oid),
                                 HANDLER_CAN_RONLY
            ));

  netsnmp_register_scalar(
          netsnmp_create_handler_registration("ccnsysLoads", handle_ccnsysLoads,
        		  	  	  	     ccnsysLoads_oid, OID_LENGTH(ccnsysLoads_oid),
                                 HANDLER_CAN_RONLY
          	 ));

  netsnmp_register_scalar(
          netsnmp_create_handler_registration("ccnsysTotalram", handle_ccnsysTotalram,
        		  	  	  	  	 ccnsysTotalram_oid, OID_LENGTH(ccnsysTotalram_oid),
                                 HANDLER_CAN_RONLY
         ));
      netsnmp_register_scalar(
          netsnmp_create_handler_registration("ccnsysFreeram", handle_ccnsysFreeram,
        		  	  	  	  	 ccnsysFreeram_oid, OID_LENGTH(ccnsysFreeram_oid),
                                 HANDLER_CAN_RONLY
          ));
      netsnmp_register_scalar(
          netsnmp_create_handler_registration("ccnsysSharedram", handle_ccnsysSharedram,
        		  	  	  	  	 ccnsysSharedram_oid, OID_LENGTH(ccnsysSharedram_oid),
                                 HANDLER_CAN_RONLY
          ));
      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysBufferram", handle_ccnsysBufferram,
            		  	  	  	 ccnsysBufferram_oid, OID_LENGTH(ccnsysBufferram_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysTotalswap", handle_ccnsysTotalswap,
            		  	  	  	 ccnsysTotalswap_oid, OID_LENGTH(ccnsysTotalswap_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysFreeswap", handle_ccnsysFreeswap,
            		  	  	  	 ccnsysFreeswap_oid, OID_LENGTH(ccnsysFreeswap_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysProcs", handle_ccnsysProcs,
            		  	  	  	 ccnsysProcs_oid, OID_LENGTH(ccnsysProcs_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysTotalhigh", handle_ccnsysTotalhigh,
            		  	  	  	 ccnsysTotalhigh_oid, OID_LENGTH(ccnsysTotalhigh_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysFreehigh", handle_ccnsysFreehigh,
            		  	  	  	 ccnsysFreehigh_oid, OID_LENGTH(ccnsysFreehigh_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysMemunit", handle_ccnsysMemunit,
            		  	  	  	 ccnsysMemunit_oid, OID_LENGTH(ccnsysMemunit_oid),
                                 HANDLER_CAN_RONLY
              ));

      netsnmp_register_scalar(
              netsnmp_create_handler_registration("ccnsysCharf", handle_ccnsysCharf,
            		  	  	  	 ccnsysCharf_oid, OID_LENGTH(ccnsysCharf_oid),
                                 HANDLER_CAN_RONLY
              ));

	/** Registro dos OIDs de ccndStatus/contentItems */
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciAccessioned", handle_ciAccessioned,
        					   ciAccessioned_oid, OID_LENGTH(ciAccessioned_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciDuplicate", handle_ciDuplicate,
                               ciDuplicate_oid, OID_LENGTH(ciDuplicate_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciSent", handle_ciSent,
                               ciSent_oid, OID_LENGTH(ciSent_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciSparse", handle_ciSparse,
                               ciSparse_oid, OID_LENGTH(ciSparse_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciStale", handle_ciStale,
                               ciStale_oid, OID_LENGTH(ciStale_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciStored", handle_ciStored,
                               ciStored_oid, OID_LENGTH(ciStored_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciHost", handle_ciHost,
                               ciHost_oid, OID_LENGTH(ciHost_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ciTimestamp", handle_ciTimestamp,
                               ciTimestamp_oid, OID_LENGTH(ciTimestamp_oid),
                               HANDLER_CAN_RONLY
        ));

	/** Registro dos OIDs de ccndStatus/interests */
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("iNames", handle_iNames,
        					   iNames_oid, OID_LENGTH(iNames_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("iNoted", handle_iNoted,
                               iNoted_oid, OID_LENGTH(iNoted_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("iPending", handle_iPending,
                               iPending_oid, OID_LENGTH(iPending_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("iPropagating", handle_iPropagating,
                               iPropagating_oid, OID_LENGTH(iPropagating_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("iHost", handle_iHost,
                               iHost_oid, OID_LENGTH(iHost_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("iTimestamp", handle_iTimestamp,
                               iTimestamp_oid, OID_LENGTH(iTimestamp_oid),
                               HANDLER_CAN_RONLY
        ));

	/** Registro dos OIDs de ccndStatus/interestTotals */
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itAccepted", handle_itAccepted,
        					   itAccepted_oid, OID_LENGTH(itAccepted_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itDropped", handle_itDropped,
        					   itDropped_oid, OID_LENGTH(itDropped_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itSent", handle_itSent,
        					   itSent_oid, OID_LENGTH(itSent_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itStuffed", handle_itStuffed,
        					   itStuffed_oid, OID_LENGTH(itStuffed_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itHost", handle_itHost,
        					   itHost_oid, OID_LENGTH(itHost_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("itTimestamp", handle_itTimestamp,
        					   itTimestamp_oid, OID_LENGTH(itTimestamp_oid),
                               HANDLER_CAN_RONLY
        ));
	
	/** Registro dos OIDs de ccndStatus/faces */
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace0", handle_fFace0,
                               fFace0_oid, OID_LENGTH(fFace0_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags0", handle_fFlags0,
                               fFlags0_oid, OID_LENGTH(fFlags0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal0", handle_fLocal0,
                               fLocal0_oid, OID_LENGTH(fLocal0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending0", handle_fPending0,
                               fPending0_oid, OID_LENGTH(fPending0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote0", handle_fRemote0,
                               fRemote0_oid, OID_LENGTH(fRemote0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost0", handle_fHost0,
                               fHost0_oid, OID_LENGTH(fHost0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp0", handle_fTimestamp0,
                               fTimestamp0_oid, OID_LENGTH(fTimestamp0_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace1", handle_fFace1,
                               fFace1_oid, OID_LENGTH(fFace1_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags1", handle_fFlags1,
                               fFlags1_oid, OID_LENGTH(fFlags1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal1", handle_fLocal1,
                               fLocal1_oid, OID_LENGTH(fLocal1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending1", handle_fPending1,
                               fPending1_oid, OID_LENGTH(fPending1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote1", handle_fRemote1,
                               fRemote1_oid, OID_LENGTH(fRemote1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost1", handle_fHost1,
                               fHost1_oid, OID_LENGTH(fHost1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp1", handle_fTimestamp1,
                               fTimestamp1_oid, OID_LENGTH(fTimestamp1_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace2", handle_fFace2,
                               fFace2_oid, OID_LENGTH(fFace2_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags2", handle_fFlags2,
                               fFlags2_oid, OID_LENGTH(fFlags2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal2", handle_fLocal2,
                               fLocal2_oid, OID_LENGTH(fLocal2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending2", handle_fPending2,
                               fPending2_oid, OID_LENGTH(fPending2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote2", handle_fRemote2,
                               fRemote2_oid, OID_LENGTH(fRemote2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost2", handle_fHost2,
                               fHost2_oid, OID_LENGTH(fHost2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp2", handle_fTimestamp2,
                               fTimestamp2_oid, OID_LENGTH(fTimestamp2_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace3", handle_fFace3,
                               fFace3_oid, OID_LENGTH(fFace3_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags3", handle_fFlags3,
                               fFlags3_oid, OID_LENGTH(fFlags3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal3", handle_fLocal3,
                               fLocal3_oid, OID_LENGTH(fLocal3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending3", handle_fPending3,
                               fPending3_oid, OID_LENGTH(fPending3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote3", handle_fRemote3,
                               fRemote3_oid, OID_LENGTH(fRemote3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost3", handle_fHost3,
                               fHost3_oid, OID_LENGTH(fHost3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp3", handle_fTimestamp3,
                               fTimestamp3_oid, OID_LENGTH(fTimestamp3_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace4", handle_fFace4,
                               fFace4_oid, OID_LENGTH(fFace4_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags4", handle_fFlags4,
                               fFlags4_oid, OID_LENGTH(fFlags4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal4", handle_fLocal4,
                               fLocal4_oid, OID_LENGTH(fLocal4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending4", handle_fPending4,
                               fPending4_oid, OID_LENGTH(fPending4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote4", handle_fRemote4,
                               fRemote4_oid, OID_LENGTH(fRemote4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost4", handle_fHost4,
                               fHost4_oid, OID_LENGTH(fHost4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp4", handle_fTimestamp4,
                               fTimestamp4_oid, OID_LENGTH(fTimestamp4_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace5", handle_fFace5,
                               fFace5_oid, OID_LENGTH(fFace5_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags5", handle_fFlags5,
                               fFlags5_oid, OID_LENGTH(fFlags5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal5", handle_fLocal5,
                               fLocal5_oid, OID_LENGTH(fLocal5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending5", handle_fPending5,
                               fPending5_oid, OID_LENGTH(fPending5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote5", handle_fRemote5,
                               fRemote5_oid, OID_LENGTH(fRemote5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost5", handle_fHost5,
                               fHost5_oid, OID_LENGTH(fHost5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp5", handle_fTimestamp5,
                               fTimestamp5_oid, OID_LENGTH(fTimestamp5_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace6", handle_fFace6,
                               fFace6_oid, OID_LENGTH(fFace6_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags6", handle_fFlags6,
                               fFlags6_oid, OID_LENGTH(fFlags6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal7", handle_fLocal7,
                               fLocal7_oid, OID_LENGTH(fLocal7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending7", handle_fPending7,
                               fPending7_oid, OID_LENGTH(fPending7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote7", handle_fRemote7,
                               fRemote7_oid, OID_LENGTH(fRemote7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost7", handle_fHost7,
                               fHost7_oid, OID_LENGTH(fHost7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp7", handle_fTimestamp7,
                               fTimestamp7_oid, OID_LENGTH(fTimestamp7_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace8", handle_fFace8,
                               fFace8_oid, OID_LENGTH(fFace8_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags8", handle_fFlags8,
                               fFlags8_oid, OID_LENGTH(fFlags8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal8", handle_fLocal8,
                               fLocal8_oid, OID_LENGTH(fLocal8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending8", handle_fPending8,
                               fPending8_oid, OID_LENGTH(fPending8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote8", handle_fRemote8,
                               fRemote8_oid, OID_LENGTH(fRemote8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost8", handle_fHost8,
                               fHost8_oid, OID_LENGTH(fHost8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp8", handle_fTimestamp8,
                               fTimestamp8_oid, OID_LENGTH(fTimestamp8_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace9", handle_fFace9,
                               fFace9_oid, OID_LENGTH(fFace9_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags9", handle_fFlags9,
                               fFlags9_oid, OID_LENGTH(fFlags9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal9", handle_fLocal9,
                               fLocal9_oid, OID_LENGTH(fLocal9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending9", handle_fPending9,
                               fPending9_oid, OID_LENGTH(fPending9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote9", handle_fRemote9,
                               fRemote9_oid, OID_LENGTH(fRemote9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost9", handle_fHost9,
                               fHost9_oid, OID_LENGTH(fHost9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp9", handle_fTimestamp9,
                               fTimestamp9_oid, OID_LENGTH(fTimestamp9_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace10", handle_fFace10,
                               fFace10_oid, OID_LENGTH(fFace10_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags10", handle_fFlags10,
                               fFlags10_oid, OID_LENGTH(fFlags10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal10", handle_fLocal10,
                               fLocal10_oid, OID_LENGTH(fLocal10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending10", handle_fPending10,
                               fPending10_oid, OID_LENGTH(fPending10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote10", handle_fRemote10,
                               fRemote10_oid, OID_LENGTH(fRemote10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost10", handle_fHost10,
                               fHost10_oid, OID_LENGTH(fHost10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp10", handle_fTimestamp10,
                               fTimestamp10_oid, OID_LENGTH(fTimestamp10_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace11", handle_fFace11,
                               fFace11_oid, OID_LENGTH(fFace11_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags11", handle_fFlags11,
                               fFlags11_oid, OID_LENGTH(fFlags11_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal11", handle_fLocal11,
                               fLocal11_oid, OID_LENGTH(fLocal11_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending11", handle_fPending11,
                               fPending11_oid, OID_LENGTH(fPending11_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote11", handle_fRemote11,
                               fRemote11_oid, OID_LENGTH(fRemote11_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost11", handle_fHost11,
                               fHost11_oid, OID_LENGTH(fHost11_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp11", handle_fTimestamp11,
                               fTimestamp11_oid, OID_LENGTH(fTimestamp11_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace12", handle_fFace12,
                               fFace12_oid, OID_LENGTH(fFace12_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags12", handle_fFlags12,
                               fFlags12_oid, OID_LENGTH(fFlags12_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal12", handle_fLocal12,
                               fLocal12_oid, OID_LENGTH(fLocal12_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending12", handle_fPending12,
                               fPending12_oid, OID_LENGTH(fPending12_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote12", handle_fRemote12,
                               fRemote12_oid, OID_LENGTH(fRemote12_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost12", handle_fHost12,
                               fHost12_oid, OID_LENGTH(fHost12_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp12", handle_fTimestamp12,
                               fTimestamp12_oid, OID_LENGTH(fTimestamp12_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFace13", handle_fFace13,
                               fFace13_oid, OID_LENGTH(fFace13_oid),
                               HANDLER_CAN_RONLY
        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fFlags13", handle_fFlags13,
                               fFlags13_oid, OID_LENGTH(fFlags13_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fLocal13", handle_fLocal13,
                               fLocal13_oid, OID_LENGTH(fLocal13_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fPending13", handle_fPending13,
                               fPending13_oid, OID_LENGTH(fPending13_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fRemote13", handle_fRemote13,
                               fRemote13_oid, OID_LENGTH(fRemote13_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fHost13", handle_fHost13,
                               fHost13_oid, OID_LENGTH(fHost13_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fTimestamp13", handle_fTimestamp13,
                               fTimestamp13_oid, OID_LENGTH(fTimestamp13_oid),
                               HANDLER_CAN_RONLY
        ));

	/** Registro dos OIDs abaixo de ccndStatus/faceActivityRates */

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace0", handle_farFace0,
                               farFace0_oid, OID_LENGTH(farFace0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn0", handle_farBytesIn0,
                               farBytesIn0_oid, OID_LENGTH(farBytesIn0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut0", handle_farBytesOut0,
                               farBytesOut0_oid, OID_LENGTH(farBytesOut0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData0", handle_farReceivedData0,
                               farReceivedData0_oid, OID_LENGTH(farReceivedData0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData0", handle_farSentData0,
                               farSentData0_oid, OID_LENGTH(farSentData0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived0", handle_farInterestsReceived0,
                               farInterestsReceived0_oid, OID_LENGTH(farInterestsReceived0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent0", handle_farInterestsSent0,
                               farInterestsSent0_oid, OID_LENGTH(farInterestsSent0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost0", handle_farHost0,
                               farHost0_oid, OID_LENGTH(farHost0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp0", handle_farTimestamp0,
                               farTimestamp0_oid, OID_LENGTH(farTimestamp0_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace1", handle_farFace1,
                               farFace1_oid, OID_LENGTH(farFace1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn1", handle_farBytesIn1,
                               farBytesIn1_oid, OID_LENGTH(farBytesIn1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut1", handle_farBytesOut1,
                               farBytesOut1_oid, OID_LENGTH(farBytesOut1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData1", handle_farReceivedData1,
                               farReceivedData1_oid, OID_LENGTH(farReceivedData1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData1", handle_farSentData1,
                               farSentData1_oid, OID_LENGTH(farSentData1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived1", handle_farInterestsReceived1,
                               farInterestsReceived1_oid, OID_LENGTH(farInterestsReceived1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent1", handle_farInterestsSent1,
                               farInterestsSent1_oid, OID_LENGTH(farInterestsSent1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost1", handle_farHost1,
                               farHost1_oid, OID_LENGTH(farHost1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp1", handle_farTimestamp1,
                               farTimestamp1_oid, OID_LENGTH(farTimestamp1_oid),
                               HANDLER_CAN_RONLY
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace2", handle_farFace2,
                               farFace2_oid, OID_LENGTH(farFace2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn2", handle_farBytesIn2,
                               farBytesIn2_oid, OID_LENGTH(farBytesIn2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut2", handle_farBytesOut2,
                               farBytesOut2_oid, OID_LENGTH(farBytesOut2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData2", handle_farReceivedData2,
                               farReceivedData2_oid, OID_LENGTH(farReceivedData2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData2", handle_farSentData2,
                               farSentData2_oid, OID_LENGTH(farSentData2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived2", handle_farInterestsReceived2,
                               farInterestsReceived2_oid, OID_LENGTH(farInterestsReceived2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent2", handle_farInterestsSent2,
                               farInterestsSent2_oid, OID_LENGTH(farInterestsSent2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost2", handle_farHost2,
                               farHost2_oid, OID_LENGTH(farHost2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp2", handle_farTimestamp2,
                               farTimestamp2_oid, OID_LENGTH(farTimestamp2_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace3", handle_farFace3,
                               farFace3_oid, OID_LENGTH(farFace3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn3", handle_farBytesIn3,
                               farBytesIn3_oid, OID_LENGTH(farBytesIn3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut3", handle_farBytesOut3,
                               farBytesOut3_oid, OID_LENGTH(farBytesOut3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData3", handle_farReceivedData3,
                               farReceivedData3_oid, OID_LENGTH(farReceivedData3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData3", handle_farSentData3,
                               farSentData3_oid, OID_LENGTH(farSentData3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived4", handle_farInterestsReceived4,
                               farInterestsReceived4_oid, OID_LENGTH(farInterestsReceived4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent4", handle_farInterestsSent4,
                               farInterestsSent4_oid, OID_LENGTH(farInterestsSent4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost4", handle_farHost4,
                               farHost4_oid, OID_LENGTH(farHost4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp4", handle_farTimestamp4,
                               farTimestamp4_oid, OID_LENGTH(farTimestamp4_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace5", handle_farFace5,
                               farFace5_oid, OID_LENGTH(farFace5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn5", handle_farBytesIn5,
                               farBytesIn5_oid, OID_LENGTH(farBytesIn5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut5", handle_farBytesOut5,
                               farBytesOut5_oid, OID_LENGTH(farBytesOut5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData5", handle_farReceivedData5,
                               farReceivedData5_oid, OID_LENGTH(farReceivedData5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData5", handle_farSentData5,
                               farSentData5_oid, OID_LENGTH(farSentData5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived5", handle_farInterestsReceived5,
                               farInterestsReceived5_oid, OID_LENGTH(farInterestsReceived5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent5", handle_farInterestsSent5,
                               farInterestsSent5_oid, OID_LENGTH(farInterestsSent5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost5", handle_farHost5,
                               farHost5_oid, OID_LENGTH(farHost5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp5", handle_farTimestamp5,
                               farTimestamp5_oid, OID_LENGTH(farTimestamp5_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace6", handle_farFace6,
                               farFace6_oid, OID_LENGTH(farFace6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn6", handle_farBytesIn6,
                               farBytesIn6_oid, OID_LENGTH(farBytesIn6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut6", handle_farBytesOut6,
                               farBytesOut6_oid, OID_LENGTH(farBytesOut6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData6", handle_farReceivedData6,
                               farReceivedData6_oid, OID_LENGTH(farReceivedData6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData6", handle_farSentData6,
                               farSentData6_oid, OID_LENGTH(farSentData6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived6", handle_farInterestsReceived6,
                               farInterestsReceived6_oid, OID_LENGTH(farInterestsReceived6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent6", handle_farInterestsSent6,
                               farInterestsSent6_oid, OID_LENGTH(farInterestsSent6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost6", handle_farHost6,
                               farHost6_oid, OID_LENGTH(farHost6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp6", handle_farTimestamp6,
                               farTimestamp6_oid, OID_LENGTH(farTimestamp6_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace7", handle_farFace7,
                               farFace7_oid, OID_LENGTH(farFace7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn7", handle_farBytesIn7,
                               farBytesIn7_oid, OID_LENGTH(farBytesIn7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut7", handle_farBytesOut7,
                               farBytesOut7_oid, OID_LENGTH(farBytesOut7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData7", handle_farReceivedData7,
                               farReceivedData7_oid, OID_LENGTH(farReceivedData7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData7", handle_farSentData7,
                               farSentData7_oid, OID_LENGTH(farSentData7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived7", handle_farInterestsReceived7,
                               farInterestsReceived7_oid, OID_LENGTH(farInterestsReceived7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent7", handle_farInterestsSent7,
                               farInterestsSent7_oid, OID_LENGTH(farInterestsSent7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost7", handle_farHost7,
                               farHost7_oid, OID_LENGTH(farHost7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp7", handle_farTimestamp7,
                               farTimestamp7_oid, OID_LENGTH(farTimestamp7_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("farFace8", handle_farFace8,
                               farFace8_oid, OID_LENGTH(farFace8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesIn8", handle_farBytesIn8,
                               farBytesIn8_oid, OID_LENGTH(farBytesIn8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farBytesOut8", handle_farBytesOut8,
                               farBytesOut8_oid, OID_LENGTH(farBytesOut8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farReceivedData8", handle_farReceivedData8,
                               farReceivedData8_oid, OID_LENGTH(farReceivedData8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farSentData8", handle_farSentData8,
                               farSentData8_oid, OID_LENGTH(farSentData8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsReceived8", handle_farInterestsReceived8,
                               farInterestsReceived8_oid, OID_LENGTH(farInterestsReceived8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farInterestsSent8", handle_farInterestsSent8,
                               farInterestsSent8_oid, OID_LENGTH(farInterestsSent8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farHost8", handle_farHost8,
                               farHost8_oid, OID_LENGTH(farHost8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("farTimestamp8", handle_farTimestamp8,
                               farTimestamp8_oid, OID_LENGTH(farTimestamp8_oid),
                               HANDLER_CAN_RONLY
        ));


	/** Registro dos OIDs abaixo de ccndStatus/forwarding */
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace0", handle_fwFace0,
                               fwFace0_oid, OID_LENGTH(fwFace0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags0", handle_fwFlags0,
                               fwFlags0_oid, OID_LENGTH(fwFlags0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath0", handle_fwPath0,
                               fwPath0_oid, OID_LENGTH(fwPath0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires0", handle_fwExpires0,
                               fwExpires0_oid, OID_LENGTH(fwExpires0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost0", handle_fwHost0,
                               fwHost0_oid, OID_LENGTH(fwHost0_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp0", handle_fwTimestamp0,
                               fwTimestamp0_oid, OID_LENGTH(fwTimestamp0_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace1", handle_fwFace1,
                               fwFace1_oid, OID_LENGTH(fwFace1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags1", handle_fwFlags1,
                               fwFlags1_oid, OID_LENGTH(fwFlags1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath1", handle_fwPath1,
                               fwPath1_oid, OID_LENGTH(fwPath1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires1", handle_fwExpires1,
                               fwExpires1_oid, OID_LENGTH(fwExpires1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost1", handle_fwHost1,
                               fwHost1_oid, OID_LENGTH(fwHost1_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp1", handle_fwTimestamp1,
                               fwTimestamp1_oid, OID_LENGTH(fwTimestamp1_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace2", handle_fwFace2,
                               fwFace2_oid, OID_LENGTH(fwFace2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags2", handle_fwFlags2,
                               fwFlags2_oid, OID_LENGTH(fwFlags2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath2", handle_fwPath2,
                               fwPath2_oid, OID_LENGTH(fwPath2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires2", handle_fwExpires2,
                               fwExpires2_oid, OID_LENGTH(fwExpires2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost2", handle_fwHost2,
                               fwHost2_oid, OID_LENGTH(fwHost2_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp2", handle_fwTimestamp2,
                               fwTimestamp2_oid, OID_LENGTH(fwTimestamp2_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace3", handle_fwFace3,
                               fwFace3_oid, OID_LENGTH(fwFace3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags3", handle_fwFlags3,
                               fwFlags3_oid, OID_LENGTH(fwFlags3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath3", handle_fwPath3,
                               fwPath3_oid, OID_LENGTH(fwPath3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires3", handle_fwExpires3,
                               fwExpires3_oid, OID_LENGTH(fwExpires3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost3", handle_fwHost3,
                               fwHost3_oid, OID_LENGTH(fwHost3_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp3", handle_fwTimestamp3,
                               fwTimestamp3_oid, OID_LENGTH(fwTimestamp3_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace4", handle_fwFace4,
                               fwFace4_oid, OID_LENGTH(fwFace4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags4", handle_fwFlags4,
                               fwFlags4_oid, OID_LENGTH(fwFlags4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath4", handle_fwPath4,
                               fwPath4_oid, OID_LENGTH(fwPath4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires4", handle_fwExpires4,
                               fwExpires4_oid, OID_LENGTH(fwExpires4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost4", handle_fwHost4,
                               fwHost4_oid, OID_LENGTH(fwHost4_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp4", handle_fwTimestamp4,
                               fwTimestamp4_oid, OID_LENGTH(fwTimestamp4_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace5", handle_fwFace5,
                               fwFace5_oid, OID_LENGTH(fwFace5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags5", handle_fwFlags5,
                               fwFlags5_oid, OID_LENGTH(fwFlags5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath5", handle_fwPath5,
                               fwPath5_oid, OID_LENGTH(fwPath5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires5", handle_fwExpires5,
                               fwExpires5_oid, OID_LENGTH(fwExpires5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost5", handle_fwHost5,
                               fwHost5_oid, OID_LENGTH(fwHost5_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp5", handle_fwTimestamp5,
                               fwTimestamp5_oid, OID_LENGTH(fwTimestamp5_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace6", handle_fwFace6,
                               fwFace6_oid, OID_LENGTH(fwFace6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags6", handle_fwFlags6,
                               fwFlags6_oid, OID_LENGTH(fwFlags6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath6", handle_fwPath6,
                               fwPath6_oid, OID_LENGTH(fwPath6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires6", handle_fwExpires6,
                               fwExpires6_oid, OID_LENGTH(fwExpires6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost6", handle_fwHost6,
                               fwHost6_oid, OID_LENGTH(fwHost6_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp6", handle_fwTimestamp6,
                               fwTimestamp6_oid, OID_LENGTH(fwTimestamp6_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace7", handle_fwFace7,
                               fwFace7_oid, OID_LENGTH(fwFace7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags7", handle_fwFlags7,
                               fwFlags7_oid, OID_LENGTH(fwFlags7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath7", handle_fwPath7,
                               fwPath7_oid, OID_LENGTH(fwPath7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires7", handle_fwExpires7,
                               fwExpires7_oid, OID_LENGTH(fwExpires7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost7", handle_fwHost7,
                               fwHost7_oid, OID_LENGTH(fwHost7_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp7", handle_fwTimestamp7,
                               fwTimestamp7_oid, OID_LENGTH(fwTimestamp7_oid),
							   HANDLER_CAN_RONLY
		));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace8", handle_fwFace8,
                               fwFace8_oid, OID_LENGTH(fwFace8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags8", handle_fwFlags8,
                               fwFlags8_oid, OID_LENGTH(fwFlags8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath8", handle_fwPath8,
                               fwPath8_oid, OID_LENGTH(fwPath8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires8", handle_fwExpires8,
                               fwExpires8_oid, OID_LENGTH(fwExpires8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost8", handle_fwHost8,
                               fwHost8_oid, OID_LENGTH(fwHost8_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp8", handle_fwTimestamp8,
                               fwTimestamp8_oid, OID_LENGTH(fwTimestamp8_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace9", handle_fwFace9,
                               fwFace9_oid, OID_LENGTH(fwFace9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags9", handle_fwFlags9,
                               fwFlags9_oid, OID_LENGTH(fwFlags9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath9", handle_fwPath9,
                               fwPath9_oid, OID_LENGTH(fwPath9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires9", handle_fwExpires9,
                               fwExpires9_oid, OID_LENGTH(fwExpires9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost9", handle_fwHost9,
                               fwHost9_oid, OID_LENGTH(fwHost9_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp9", handle_fwTimestamp9,
                               fwTimestamp9_oid, OID_LENGTH(fwTimestamp9_oid),
                               HANDLER_CAN_RONLY
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFace10", handle_fwFace10,
                               fwFace10_oid, OID_LENGTH(fwFace10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwFlags10", handle_fwFlags10,
                               fwFlags10_oid, OID_LENGTH(fwFlags10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwPath10", handle_fwPath10,
                               fwPath10_oid, OID_LENGTH(fwPath10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwExpires10", handle_fwExpires10,
                               fwExpires10_oid, OID_LENGTH(fwExpires10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwHost10", handle_fwHost10,
                               fwHost10_oid, OID_LENGTH(fwHost10_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fwTimestamp10", handle_fwTimestamp10,
                               fwTimestamp10_oid, OID_LENGTH(fwTimestamp10_oid),
                               HANDLER_CAN_RONLY
        ));



	/** Registro da ccnMIB com tratamento do campo contextName de ate 100 NEs, string "r[1-100]" */

  char my_str[100];
  int i;

 /** ########## ccnSystem ########## */

  for (i=0;i<=100;i++)
   {
 	snprintf(my_str, 100, "r%d", i);
 	reg = netsnmp_create_handler_registration("ccnsysName", handle_ccnsysName,
 	ccnsysName_oid, OID_LENGTH(ccnsysName_oid),
    HANDLER_CAN_RONLY);
 	reg->contextName = my_str;
 	netsnmp_register_scalar(reg);
   }

    for (i=0;i<=100;i++)
     {
  	snprintf(my_str, 100, "r%d", i);
  	reg = netsnmp_create_handler_registration("ccnsysUptime", handle_ccnsysUptime,
  	ccnsysUptime_oid, OID_LENGTH(ccnsysUptime_oid),
    HANDLER_CAN_RONLY);
  	reg->contextName = my_str;
  	netsnmp_register_scalar(reg);
     }

    for (i=0;i<=100;i++)
 	{
 	snprintf(my_str, 100, "r%d", i);
 	reg = netsnmp_create_handler_registration("ccnsysLoads", handle_ccnsysLoads,
 	ccnsysLoads_oid, OID_LENGTH(ccnsysLoads_oid),
 	HANDLER_CAN_RONLY);
 	reg->contextName = my_str;
 	netsnmp_register_scalar(reg);
 	}

    for (i=0;i<=100;i++)
    	{
    	snprintf(my_str, 100, "r%d", i);
    	reg = netsnmp_create_handler_registration("ccnsysTotalram", handle_ccnsysTotalram,
    	ccnsysTotalram_oid, OID_LENGTH(ccnsysTotalram_oid),
    	HANDLER_CAN_RONLY);
    	reg->contextName = my_str;
    	netsnmp_register_scalar(reg);
    	}

    for (i=0;i<=100;i++)
       	{
       	snprintf(my_str, 100, "r%d", i);
       	reg = netsnmp_create_handler_registration("ccnsysFreeram", handle_ccnsysFreeram,
       	ccnsysFreeram_oid, OID_LENGTH(ccnsysFreeram_oid),
       	HANDLER_CAN_RONLY);
       	reg->contextName = my_str;
       	netsnmp_register_scalar(reg);
       	}

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysSharedram", handle_ccnsysSharedram,
         ccnsysSharedram_oid, OID_LENGTH(ccnsysSharedram_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysBufferram", handle_ccnsysBufferram,
         ccnsysBufferram_oid, OID_LENGTH(ccnsysBufferram_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysTotalswap", handle_ccnsysTotalswap,
         ccnsysTotalswap_oid, OID_LENGTH(ccnsysTotalswap_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysFreeswap", handle_ccnsysFreeswap,
         ccnsysFreeswap_oid, OID_LENGTH(ccnsysFreeswap_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysProcs", handle_ccnsysProcs,
         ccnsysProcs_oid, OID_LENGTH(ccnsysProcs_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysTotalhigh", handle_ccnsysTotalhigh,
         ccnsysTotalhigh_oid, OID_LENGTH(ccnsysTotalhigh_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysFreehigh", handle_ccnsysFreehigh,
         ccnsysFreehigh_oid, OID_LENGTH(ccnsysFreehigh_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysMemunit", handle_ccnsysMemunit,
         ccnsysMemunit_oid, OID_LENGTH(ccnsysMemunit_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    for (i=0;i<=100;i++)
         {
         snprintf(my_str, 100, "r%d", i);
         reg = netsnmp_create_handler_registration("ccnsysCharf", handle_ccnsysCharf,
         ccnsysCharf_oid, OID_LENGTH(ccnsysCharf_oid),
         HANDLER_CAN_RONLY);
         reg->contextName = my_str;
         netsnmp_register_scalar(reg);
         }

    /** ########## ccndStatus/contentItems ########## */

    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciAccessioned", handle_ciAccessioned,
            ciAccessioned_oid, OID_LENGTH(ciAccessioned_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }

    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciDuplicate", handle_ciDuplicate,
            ciDuplicate_oid, OID_LENGTH(ciDuplicate_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }

    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciSent", handle_ciSent,
            ciSent_oid, OID_LENGTH(ciSent_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }
    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciSparse", handle_ciSparse,
            ciSparse_oid, OID_LENGTH(ciSparse_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }

    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciStale", handle_ciStale,
            ciStale_oid, OID_LENGTH(ciStale_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }
    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciStored", handle_ciStored,
            ciStored_oid, OID_LENGTH(ciStored_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }
    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciHost", handle_ciHost,
            ciHost_oid, OID_LENGTH(ciHost_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }

    	for (i=0;i<=100;i++)
            {
            snprintf(my_str, 100, "r%d", i);
            reg = netsnmp_create_handler_registration("ciTimestamp", handle_ciTimestamp,
            ciTimestamp_oid, OID_LENGTH(ciTimestamp_oid),
            HANDLER_CAN_RONLY);
            reg->contextName = my_str;
            netsnmp_register_scalar(reg);
            }

    /** ########## ccndStatus/interests ########## */

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iNames", handle_iNames,
        iNames_oid, OID_LENGTH(iNames_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iNoted", handle_iNoted,
        iNoted_oid, OID_LENGTH(iNoted_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iPending", handle_iPending,
        iPending_oid, OID_LENGTH(iPending_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iPropagating", handle_iPropagating,
        iPropagating_oid, OID_LENGTH(iPropagating_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iHost", handle_iHost,
        iHost_oid, OID_LENGTH(iHost_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("iTimestamp", handle_iTimestamp,
        iTimestamp_oid, OID_LENGTH(iTimestamp_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	/** ########## ccndStatus/interestTotals ########## */

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itAccepted", handle_itAccepted,
        itAccepted_oid, OID_LENGTH(itAccepted_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itDropped", handle_itDropped,
        itDropped_oid, OID_LENGTH(itDropped_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }
	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itSent", handle_itSent,
        itSent_oid, OID_LENGTH(itSent_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }
	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itStuffed", handle_itStuffed,
        itStuffed_oid, OID_LENGTH(itStuffed_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }
	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itHost", handle_itHost,
        itHost_oid, OID_LENGTH(itHost_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("itTimestamp", handle_itTimestamp,
        itTimestamp_oid, OID_LENGTH(itTimestamp_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	/** ########## ccndStatus/faces ########## */

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace0", handle_fFace0,
        fFace0_oid, OID_LENGTH(fFace0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags0", handle_fFlags0,
        fFlags0_oid, OID_LENGTH(fFlags0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal0", handle_fLocal0,
        fLocal0_oid, OID_LENGTH(fLocal0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending0", handle_fPending0,
        fPending0_oid, OID_LENGTH(fPending0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote0", handle_fRemote0,
        fRemote0_oid, OID_LENGTH(fRemote0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost0", handle_fHost0,
        fHost0_oid, OID_LENGTH(fHost0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp0", handle_fTimestamp0,
        fTimestamp0_oid, OID_LENGTH(fTimestamp0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace1", handle_fFace1,
        fFace1_oid, OID_LENGTH(fFace1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags1", handle_fFlags1,
        fFlags1_oid, OID_LENGTH(fFlags1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal1", handle_fLocal1,
        fLocal1_oid, OID_LENGTH(fLocal1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending1", handle_fPending1,
        fPending1_oid, OID_LENGTH(fPending1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote1", handle_fRemote1,
        fRemote1_oid, OID_LENGTH(fRemote1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost1", handle_fHost1,
        fHost1_oid, OID_LENGTH(fHost1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp1", handle_fTimestamp1,
        fTimestamp1_oid, OID_LENGTH(fTimestamp1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace2", handle_fFace2,
        fFace2_oid, OID_LENGTH(fFace2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags2", handle_fFlags2,
        fFlags2_oid, OID_LENGTH(fFlags2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal2", handle_fLocal2,
        fLocal2_oid, OID_LENGTH(fLocal2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending2", handle_fPending2,
        fPending2_oid, OID_LENGTH(fPending2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote2", handle_fRemote2,
        fRemote2_oid, OID_LENGTH(fRemote2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost2", handle_fHost2,
        fHost2_oid, OID_LENGTH(fHost2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp2", handle_fTimestamp2,
        fTimestamp2_oid, OID_LENGTH(fTimestamp2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace3", handle_fFace3,
        fFace3_oid, OID_LENGTH(fFace3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags3", handle_fFlags3,
        fFlags3_oid, OID_LENGTH(fFlags3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal3", handle_fLocal3,
        fLocal3_oid, OID_LENGTH(fLocal3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending3", handle_fPending3,
        fPending3_oid, OID_LENGTH(fPending3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote3", handle_fRemote3,
        fRemote3_oid, OID_LENGTH(fRemote3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost3", handle_fHost3,
        fHost3_oid, OID_LENGTH(fHost3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp3", handle_fTimestamp3,
        fTimestamp3_oid, OID_LENGTH(fTimestamp3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace4", handle_fFace4,
        fFace4_oid, OID_LENGTH(fFace4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags4", handle_fFlags4,
        fFlags4_oid, OID_LENGTH(fFlags4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal4", handle_fLocal4,
        fLocal4_oid, OID_LENGTH(fLocal4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending4", handle_fPending4,
        fPending4_oid, OID_LENGTH(fPending4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote4", handle_fRemote4,
        fRemote4_oid, OID_LENGTH(fRemote4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost4", handle_fHost4,
        fHost4_oid, OID_LENGTH(fHost4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp4", handle_fTimestamp4,
        fTimestamp4_oid, OID_LENGTH(fTimestamp4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace5", handle_fFace5,
        fFace5_oid, OID_LENGTH(fFace5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags5", handle_fFlags5,
        fFlags5_oid, OID_LENGTH(fFlags5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal5", handle_fLocal5,
        fLocal5_oid, OID_LENGTH(fLocal5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending5", handle_fPending5,
        fPending5_oid, OID_LENGTH(fPending5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote5", handle_fRemote5,
        fRemote5_oid, OID_LENGTH(fRemote5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost5", handle_fHost5,
        fHost5_oid, OID_LENGTH(fHost5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp5", handle_fTimestamp5,
        fTimestamp5_oid, OID_LENGTH(fTimestamp5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace6", handle_fFace6,
        fFace6_oid, OID_LENGTH(fFace6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags6", handle_fFlags6,
        fFlags6_oid, OID_LENGTH(fFlags6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal6", handle_fLocal6,
        fLocal6_oid, OID_LENGTH(fLocal6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending6", handle_fPending6,
        fPending6_oid, OID_LENGTH(fPending6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote6", handle_fRemote6,
        fRemote6_oid, OID_LENGTH(fRemote6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost6", handle_fHost6,
        fHost6_oid, OID_LENGTH(fHost6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp6", handle_fTimestamp6,
        fTimestamp6_oid, OID_LENGTH(fTimestamp6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace7", handle_fFace7,
        fFace7_oid, OID_LENGTH(fFace7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags7", handle_fFlags7,
        fFlags7_oid, OID_LENGTH(fFlags7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal7", handle_fLocal7,
        fLocal7_oid, OID_LENGTH(fLocal7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending7", handle_fPending7,
        fPending7_oid, OID_LENGTH(fPending7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote7", handle_fRemote7,
        fRemote7_oid, OID_LENGTH(fRemote7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost7", handle_fHost7,
        fHost7_oid, OID_LENGTH(fHost7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp7", handle_fTimestamp7,
        fTimestamp7_oid, OID_LENGTH(fTimestamp7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace8", handle_fFace8,
        fFace8_oid, OID_LENGTH(fFace8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags8", handle_fFlags8,
        fFlags8_oid, OID_LENGTH(fFlags8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal8", handle_fLocal8,
        fLocal8_oid, OID_LENGTH(fLocal8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending8", handle_fPending8,
        fPending8_oid, OID_LENGTH(fPending8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote8", handle_fRemote8,
        fRemote8_oid, OID_LENGTH(fRemote8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost8", handle_fHost8,
        fHost8_oid, OID_LENGTH(fHost8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp8", handle_fTimestamp8,
        fTimestamp8_oid, OID_LENGTH(fTimestamp8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace9", handle_fFace9,
        fFace9_oid, OID_LENGTH(fFace9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags9", handle_fFlags9,
        fFlags9_oid, OID_LENGTH(fFlags9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal9", handle_fLocal9,
        fLocal9_oid, OID_LENGTH(fLocal9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending9", handle_fPending9,
        fPending9_oid, OID_LENGTH(fPending9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote9", handle_fRemote9,
        fRemote9_oid, OID_LENGTH(fRemote9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost9", handle_fHost9,
        fHost9_oid, OID_LENGTH(fHost9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp9", handle_fTimestamp9,
        fTimestamp9_oid, OID_LENGTH(fTimestamp9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace10", handle_fFace10,
        fFace10_oid, OID_LENGTH(fFace10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags10", handle_fFlags10,
        fFlags10_oid, OID_LENGTH(fFlags10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal10", handle_fLocal10,
        fLocal10_oid, OID_LENGTH(fLocal10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending10", handle_fPending10,
        fPending10_oid, OID_LENGTH(fPending10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote10", handle_fRemote10,
        fRemote10_oid, OID_LENGTH(fRemote10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost10", handle_fHost10,
        fHost10_oid, OID_LENGTH(fHost10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp10", handle_fTimestamp10,
        fTimestamp10_oid, OID_LENGTH(fTimestamp10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace11", handle_fFace11,
        fFace11_oid, OID_LENGTH(fFace11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags11", handle_fFlags11,
        fFlags11_oid, OID_LENGTH(fFlags11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal11", handle_fLocal11,
        fLocal11_oid, OID_LENGTH(fLocal11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending11", handle_fPending11,
        fPending11_oid, OID_LENGTH(fPending11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote11", handle_fRemote11,
        fRemote11_oid, OID_LENGTH(fRemote11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost11", handle_fHost11,
        fHost11_oid, OID_LENGTH(fHost11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp11", handle_fTimestamp11,
        fTimestamp11_oid, OID_LENGTH(fTimestamp11_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace12", handle_fFace12,
        fFace12_oid, OID_LENGTH(fFace12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags12", handle_fFlags12,
        fFlags12_oid, OID_LENGTH(fFlags12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal12", handle_fLocal12,
        fLocal12_oid, OID_LENGTH(fLocal12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending12", handle_fPending12,
        fPending12_oid, OID_LENGTH(fPending12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote12", handle_fRemote12,
        fRemote12_oid, OID_LENGTH(fRemote12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost12", handle_fHost12,
        fHost12_oid, OID_LENGTH(fHost12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp12", handle_fTimestamp12,
        fTimestamp12_oid, OID_LENGTH(fTimestamp12_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFace13", handle_fFace13,
        fFace13_oid, OID_LENGTH(fFace13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fFlags13", handle_fFlags13,
        fFlags13_oid, OID_LENGTH(fFlags13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fLocal13", handle_fLocal13,
        fLocal13_oid, OID_LENGTH(fLocal13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fPending13", handle_fPending13,
        fPending13_oid, OID_LENGTH(fPending13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fRemote13", handle_fRemote13,
        fRemote13_oid, OID_LENGTH(fRemote13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fHost13", handle_fHost13,
        fHost13_oid, OID_LENGTH(fHost13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fTimestamp13", handle_fTimestamp13,
        fTimestamp13_oid, OID_LENGTH(fTimestamp13_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }


	/** ########## ccndStatus/faceActivityRates ########## */

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace0", handle_farFace0,
        farFace0_oid, OID_LENGTH(farFace0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn0", handle_farBytesIn0,
        farBytesIn0_oid, OID_LENGTH(farBytesIn0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut0", handle_farBytesOut0,
        farBytesOut0_oid, OID_LENGTH(farBytesOut0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData0", handle_farReceivedData0,
        farReceivedData0_oid, OID_LENGTH(farReceivedData0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData0", handle_farSentData0,
        farSentData0_oid, OID_LENGTH(farSentData0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived0", handle_farInterestsReceived0,
        farInterestsReceived0_oid, OID_LENGTH(farInterestsReceived0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent0", handle_farInterestsSent0,
        farInterestsSent0_oid, OID_LENGTH(farInterestsSent0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost0", handle_farHost0,
        farHost0_oid, OID_LENGTH(farHost0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp0", handle_farTimestamp0,
        farTimestamp0_oid, OID_LENGTH(farTimestamp0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace1", handle_farFace1,
        farFace1_oid, OID_LENGTH(farFace1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn1", handle_farBytesIn1,
        farBytesIn1_oid, OID_LENGTH(farBytesIn1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut1", handle_farBytesOut1,
        farBytesOut1_oid, OID_LENGTH(farBytesOut1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData1", handle_farReceivedData1,
        farReceivedData1_oid, OID_LENGTH(farReceivedData1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData1", handle_farSentData1,
        farSentData1_oid, OID_LENGTH(farSentData1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived1", handle_farInterestsReceived1,
        farInterestsReceived1_oid, OID_LENGTH(farInterestsReceived1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent1", handle_farInterestsSent1,
        farInterestsSent1_oid, OID_LENGTH(farInterestsSent1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost1", handle_farHost1,
        farHost1_oid, OID_LENGTH(farHost1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp1", handle_farTimestamp1,
        farTimestamp1_oid, OID_LENGTH(farTimestamp1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace2", handle_farFace2,
        farFace2_oid, OID_LENGTH(farFace2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn2", handle_farBytesIn2,
        farBytesIn2_oid, OID_LENGTH(farBytesIn2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut2", handle_farBytesOut2,
        farBytesOut2_oid, OID_LENGTH(farBytesOut2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData2", handle_farReceivedData2,
        farReceivedData2_oid, OID_LENGTH(farReceivedData2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData2", handle_farSentData2,
        farSentData2_oid, OID_LENGTH(farSentData2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived2", handle_farInterestsReceived2,
        farInterestsReceived2_oid, OID_LENGTH(farInterestsReceived2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent2", handle_farInterestsSent2,
        farInterestsSent2_oid, OID_LENGTH(farInterestsSent2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost2", handle_farHost2,
        farHost2_oid, OID_LENGTH(farHost2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp2", handle_farTimestamp2,
        farTimestamp2_oid, OID_LENGTH(farTimestamp2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace3", handle_farFace3,
        farFace3_oid, OID_LENGTH(farFace3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn3", handle_farBytesIn3,
        farBytesIn3_oid, OID_LENGTH(farBytesIn3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut3", handle_farBytesOut3,
        farBytesOut3_oid, OID_LENGTH(farBytesOut3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData3", handle_farReceivedData3,
        farReceivedData3_oid, OID_LENGTH(farReceivedData3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData3", handle_farSentData3,
        farSentData3_oid, OID_LENGTH(farSentData3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived3", handle_farInterestsReceived3,
        farInterestsReceived3_oid, OID_LENGTH(farInterestsReceived3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent3", handle_farInterestsSent3,
        farInterestsSent3_oid, OID_LENGTH(farInterestsSent3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost3", handle_farHost3,
        farHost3_oid, OID_LENGTH(farHost3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp3", handle_farTimestamp3,
        farTimestamp3_oid, OID_LENGTH(farTimestamp3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace4", handle_farFace4,
        farFace4_oid, OID_LENGTH(farFace4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn4", handle_farBytesIn4,
        farBytesIn4_oid, OID_LENGTH(farBytesIn4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut4", handle_farBytesOut4,
        farBytesOut4_oid, OID_LENGTH(farBytesOut4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData4", handle_farReceivedData4,
        farReceivedData4_oid, OID_LENGTH(farReceivedData4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData4", handle_farSentData4,
        farSentData4_oid, OID_LENGTH(farSentData4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived4", handle_farInterestsReceived4,
        farInterestsReceived4_oid, OID_LENGTH(farInterestsReceived4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent4", handle_farInterestsSent4,
        farInterestsSent4_oid, OID_LENGTH(farInterestsSent4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost4", handle_farHost4,
        farHost4_oid, OID_LENGTH(farHost4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp4", handle_farTimestamp4,
        farTimestamp4_oid, OID_LENGTH(farTimestamp4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace5", handle_farFace5,
        farFace5_oid, OID_LENGTH(farFace5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn5", handle_farBytesIn5,
        farBytesIn5_oid, OID_LENGTH(farBytesIn5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut5", handle_farBytesOut5,
        farBytesOut5_oid, OID_LENGTH(farBytesOut5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData5", handle_farReceivedData5,
        farReceivedData5_oid, OID_LENGTH(farReceivedData5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData5", handle_farSentData5,
        farSentData5_oid, OID_LENGTH(farSentData5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived5", handle_farInterestsReceived5,
        farInterestsReceived5_oid, OID_LENGTH(farInterestsReceived5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent5", handle_farInterestsSent5,
        farInterestsSent5_oid, OID_LENGTH(farInterestsSent5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost5", handle_farHost5,
        farHost5_oid, OID_LENGTH(farHost5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp5", handle_farTimestamp5,
        farTimestamp5_oid, OID_LENGTH(farTimestamp5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace6", handle_farFace6,
        farFace6_oid, OID_LENGTH(farFace6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn6", handle_farBytesIn6,
        farBytesIn6_oid, OID_LENGTH(farBytesIn6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut6", handle_farBytesOut6,
        farBytesOut6_oid, OID_LENGTH(farBytesOut6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData6", handle_farReceivedData6,
        farReceivedData6_oid, OID_LENGTH(farReceivedData6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData6", handle_farSentData6,
        farSentData6_oid, OID_LENGTH(farSentData6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived6", handle_farInterestsReceived6,
        farInterestsReceived6_oid, OID_LENGTH(farInterestsReceived6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent6", handle_farInterestsSent6,
        farInterestsSent6_oid, OID_LENGTH(farInterestsSent6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost6", handle_farHost6,
        farHost6_oid, OID_LENGTH(farHost6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp6", handle_farTimestamp6,
        farTimestamp6_oid, OID_LENGTH(farTimestamp6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace7", handle_farFace7,
        farFace7_oid, OID_LENGTH(farFace7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn7", handle_farBytesIn7,
        farBytesIn7_oid, OID_LENGTH(farBytesIn7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut7", handle_farBytesOut7,
        farBytesOut7_oid, OID_LENGTH(farBytesOut7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData7", handle_farReceivedData7,
        farReceivedData7_oid, OID_LENGTH(farReceivedData7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData7", handle_farSentData7,
        farSentData7_oid, OID_LENGTH(farSentData7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived7", handle_farInterestsReceived7,
        farInterestsReceived7_oid, OID_LENGTH(farInterestsReceived7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent7", handle_farInterestsSent7,
        farInterestsSent7_oid, OID_LENGTH(farInterestsSent7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost7", handle_farHost7,
        farHost7_oid, OID_LENGTH(farHost7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp7", handle_farTimestamp7,
        farTimestamp7_oid, OID_LENGTH(farTimestamp7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farFace8", handle_farFace8,
        farFace8_oid, OID_LENGTH(farFace8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesIn8", handle_farBytesIn8,
        farBytesIn8_oid, OID_LENGTH(farBytesIn8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farBytesOut8", handle_farBytesOut8,
        farBytesOut8_oid, OID_LENGTH(farBytesOut8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farReceivedData8", handle_farReceivedData8,
        farReceivedData8_oid, OID_LENGTH(farReceivedData8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farSentData8", handle_farSentData8,
        farSentData8_oid, OID_LENGTH(farSentData8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsReceived8", handle_farInterestsReceived8,
        farInterestsReceived8_oid, OID_LENGTH(farInterestsReceived8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farInterestsSent8", handle_farInterestsSent8,
        farInterestsSent8_oid, OID_LENGTH(farInterestsSent8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farHost8", handle_farHost8,
        farHost8_oid, OID_LENGTH(farHost8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("farTimestamp8", handle_farTimestamp8,
        farTimestamp8_oid, OID_LENGTH(farTimestamp8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }


	/** ########## ccndStatus/forwarding ########## */

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace0", handle_fwFace0,
        fwFace0_oid, OID_LENGTH(fwFace0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags0", handle_fwFlags0,
        fwFlags0_oid, OID_LENGTH(fwFlags0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath0", handle_fwPath0,
        fwPath0_oid, OID_LENGTH(fwPath0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires0", handle_fwExpires0,
        fwExpires0_oid, OID_LENGTH(fwExpires0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost0", handle_fwHost0,
        fwHost0_oid, OID_LENGTH(fwHost0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp0", handle_fwTimestamp0,
        fwTimestamp0_oid, OID_LENGTH(fwTimestamp0_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace1", handle_fwFace1,
        fwFace1_oid, OID_LENGTH(fwFace1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags1", handle_fwFlags1,
        fwFlags1_oid, OID_LENGTH(fwFlags1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath1", handle_fwPath1,
        fwPath1_oid, OID_LENGTH(fwPath1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires1", handle_fwExpires1,
        fwExpires1_oid, OID_LENGTH(fwExpires1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost1", handle_fwHost1,
        fwHost1_oid, OID_LENGTH(fwHost1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp1", handle_fwTimestamp1,
        fwTimestamp1_oid, OID_LENGTH(fwTimestamp1_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace2", handle_fwFace2,
        fwFace2_oid, OID_LENGTH(fwFace2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags2", handle_fwFlags2,
        fwFlags2_oid, OID_LENGTH(fwFlags2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath2", handle_fwPath2,
        fwPath2_oid, OID_LENGTH(fwPath2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires2", handle_fwExpires2,
        fwExpires2_oid, OID_LENGTH(fwExpires2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost2", handle_fwHost2,
        fwHost2_oid, OID_LENGTH(fwHost2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp2", handle_fwTimestamp2,
        fwTimestamp2_oid, OID_LENGTH(fwTimestamp2_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace3", handle_fwFace3,
        fwFace3_oid, OID_LENGTH(fwFace3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags3", handle_fwFlags3,
        fwFlags3_oid, OID_LENGTH(fwFlags3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath3", handle_fwPath3,
        fwPath3_oid, OID_LENGTH(fwPath3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires3", handle_fwExpires3,
        fwExpires3_oid, OID_LENGTH(fwExpires3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost3", handle_fwHost3,
        fwHost3_oid, OID_LENGTH(fwHost3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp3", handle_fwTimestamp3,
        fwTimestamp3_oid, OID_LENGTH(fwTimestamp3_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace4", handle_fwFace4,
        fwFace4_oid, OID_LENGTH(fwFace4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags4", handle_fwFlags4,
        fwFlags4_oid, OID_LENGTH(fwFlags4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath4", handle_fwPath4,
        fwPath4_oid, OID_LENGTH(fwPath4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires4", handle_fwExpires4,
        fwExpires4_oid, OID_LENGTH(fwExpires4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost4", handle_fwHost4,
        fwHost4_oid, OID_LENGTH(fwHost4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp4", handle_fwTimestamp4,
        fwTimestamp4_oid, OID_LENGTH(fwTimestamp4_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace5", handle_fwFace5,
        fwFace5_oid, OID_LENGTH(fwFace5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags5", handle_fwFlags5,
        fwFlags5_oid, OID_LENGTH(fwFlags5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath5", handle_fwPath5,
        fwPath5_oid, OID_LENGTH(fwPath5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires5", handle_fwExpires5,
        fwExpires5_oid, OID_LENGTH(fwExpires5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost5", handle_fwHost5,
        fwHost5_oid, OID_LENGTH(fwHost5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp5", handle_fwTimestamp5,
        fwTimestamp5_oid, OID_LENGTH(fwTimestamp5_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace6", handle_fwFace6,
        fwFace6_oid, OID_LENGTH(fwFace6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags6", handle_fwFlags6,
        fwFlags6_oid, OID_LENGTH(fwFlags6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath6", handle_fwPath6,
        fwPath6_oid, OID_LENGTH(fwPath6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires6", handle_fwExpires6,
        fwExpires6_oid, OID_LENGTH(fwExpires6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost6", handle_fwHost6,
        fwHost6_oid, OID_LENGTH(fwHost6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp6", handle_fwTimestamp6,
        fwTimestamp6_oid, OID_LENGTH(fwTimestamp6_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace7", handle_fwFace7,
        fwFace7_oid, OID_LENGTH(fwFace7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags7", handle_fwFlags7,
        fwFlags7_oid, OID_LENGTH(fwFlags7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath7", handle_fwPath7,
        fwPath7_oid, OID_LENGTH(fwPath7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires7", handle_fwExpires7,
        fwExpires7_oid, OID_LENGTH(fwExpires7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost7", handle_fwHost7,
        fwHost7_oid, OID_LENGTH(fwHost7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp7", handle_fwTimestamp7,
        fwTimestamp7_oid, OID_LENGTH(fwTimestamp7_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace8", handle_fwFace8,
        fwFace8_oid, OID_LENGTH(fwFace8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags8", handle_fwFlags8,
        fwFlags8_oid, OID_LENGTH(fwFlags8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath8", handle_fwPath8,
        fwPath8_oid, OID_LENGTH(fwPath8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires8", handle_fwExpires8,
        fwExpires8_oid, OID_LENGTH(fwExpires8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost8", handle_fwHost8,
        fwHost8_oid, OID_LENGTH(fwHost8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp8", handle_fwTimestamp8,
        fwTimestamp8_oid, OID_LENGTH(fwTimestamp8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace9", handle_fwFace9,
        fwFace9_oid, OID_LENGTH(fwFace9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags9", handle_fwFlags9,
        fwFlags9_oid, OID_LENGTH(fwFlags9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath9", handle_fwPath9,
        fwPath9_oid, OID_LENGTH(fwPath8_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires9", handle_fwExpires9,
        fwExpires9_oid, OID_LENGTH(fwExpires9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost9", handle_fwHost9,
        fwHost9_oid, OID_LENGTH(fwHost9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp9", handle_fwTimestamp9,
        fwTimestamp9_oid, OID_LENGTH(fwTimestamp9_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFace10", handle_fwFace10,
        fwFace10_oid, OID_LENGTH(fwFace10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwFlags10", handle_fwFlags10,
        fwFlags10_oid, OID_LENGTH(fwFlags10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwPath10", handle_fwPath10,
        fwPath10_oid, OID_LENGTH(fwPath10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwExpires10", handle_fwExpires10,
        fwExpires10_oid, OID_LENGTH(fwExpires10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwHost10", handle_fwHost10,
        fwHost10_oid, OID_LENGTH(fwHost10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

	for (i=0;i<=100;i++)
        {
        snprintf(my_str, 100, "r%d", i);
        reg = netsnmp_create_handler_registration("fwTimestamp10", handle_fwTimestamp10,
        fwTimestamp10_oid, OID_LENGTH(fwTimestamp10_oid),
        HANDLER_CAN_RONLY);
        reg->contextName = my_str;
        netsnmp_register_scalar(reg);
        }

}

/* ######################### Handle ccnSystem ######################### */

int handle_ccnsysName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

						FILE *in;
					    extern FILE *popen();
					    char ccnsysName[512];
					    char contextName[32];
					    char command[512];

					    if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
					    		         printf("ERROR: too long contextName");
					    		         exit(1);
					   }
					    memset(contextName, 0, 32);
					    memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
					    memset(command, 0, 512);
					    snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysName", contextName);

					    if(!(in = popen(command, "r"))){

					    exit(1);
					   }

					    while(fgets(ccnsysName, sizeof(ccnsysName), in)!=NULL){
					        printf("%s", ccnsysName);
					    }
					    pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysName,
			            sizeof( ccnsysName ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysName\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysUptime(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

					FILE *in;
				    extern FILE *popen();
				    char ccnsysUptime[512];
				    char contextName[32];
				    char command[512];

				    if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
				    		         printf("ERROR: too long contextName");
				    		         exit(1);
				   }
				    memset(contextName, 0, 32);
				    memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
				    memset(command, 0, 512);
				    snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysUptime", contextName);

				    if(!(in = popen(command, "r"))){

				    exit(1);
				   }

				    while(fgets(ccnsysUptime, sizeof(ccnsysUptime), in)!=NULL){
				        printf("%s", ccnsysUptime);
				    }
				    pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysUptime,
			            sizeof( ccnsysUptime ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysUptime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysLoads(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

					FILE *in;
					extern FILE *popen();
					char ccnsysLoads[512];
					char contextName[32];
					char command[512];

					if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
						    		 printf("ERROR: too long contextName");
						    		 exit(1);
					}
					memset(contextName, 0, 32);
					memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
					memset(command, 0, 512);
					snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysLoads", contextName);

					if(!(in = popen(command, "r"))){

					exit(1);
					}

					while(fgets(ccnsysLoads, sizeof(ccnsysLoads), in)!=NULL){
					printf("%s", ccnsysLoads);
					}
					pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysLoads,
			            sizeof( ccnsysLoads ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysLoads\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysTotalram(netsnmp_mib_handler *handler,
						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static unsigned char ccnsysContact[] = "contato@contato.com";

				FILE *in;
			    extern FILE *popen();
			    char ccnsysTotalram[512];
			    char contextName[32];
			    char command[512];

			    if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);
			   }
			    memset(contextName, 0, 32);
			    memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			    memset(command, 0, 512);
			    snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysTotalram", contextName);

			    if(!(in = popen(command, "r"))){

			    exit(1);
			   }

			    while(fgets(ccnsysTotalram, sizeof(ccnsysTotalram), in)!=NULL){
			        printf("%s", ccnsysTotalram);
			    }
			    pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysTotalram,
                                    sizeof( ccnsysTotalram ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysTotalram\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysFreeram(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static unsigned char ccnsysFreeram[] = "NE3";

			FILE *in;
			extern FILE *popen();
			char ccnsysFreeram[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
					         printf("ERROR: too long contextName");
			  		         exit(1);
			}
			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysFreeram", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			}

			while(fgets(ccnsysFreeram, sizeof(ccnsysFreeram), in)!=NULL){
			       printf("%s", ccnsysFreeram);
			}
				    pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysFreeram,
                                    sizeof( ccnsysFreeram ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysFreeram\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysSharedram(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static unsigned char ccnsysFreeram[] = "NE3";

			FILE *in;
			extern FILE *popen();
			char ccnsysSharedram[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
					         printf("ERROR: too long contextName");
			  		         exit(1);
			}
			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysSharedram", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			}

			while(fgets(ccnsysSharedram, sizeof(ccnsysSharedram), in)!=NULL){
			       printf("%s", ccnsysSharedram);
			}
				    pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysSharedram,
                                    sizeof( ccnsysSharedram ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysSharedram\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysBufferram(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysBufferram[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysBufferram", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysBufferram, sizeof(ccnsysBufferram), in)!=NULL){
			       printf("%s", ccnsysBufferram);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysBufferram,
			            sizeof( ccnsysBufferram ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysBufferram\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysTotalswap(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysTotalswap[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysTotalswap", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysTotalswap, sizeof(ccnsysTotalswap), in)!=NULL){
			       printf("%s", ccnsysTotalswap);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysTotalswap,
			            sizeof( ccnsysTotalswap ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysTotalswap\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysFreeswap(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysFreeswap[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysFreeswap", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysFreeswap, sizeof(ccnsysFreeswap), in)!=NULL){
			       printf("%s", ccnsysFreeswap);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysFreeswap,
			            sizeof( ccnsysFreeswap ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysFreeswap\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysProcs(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysProcs[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysProcs", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysProcs, sizeof(ccnsysProcs), in)!=NULL){
			       printf("%s", ccnsysProcs);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysProcs,
			            sizeof( ccnsysProcs ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysProcs\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysTotalhigh(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysTotalhigh[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysTotalhigh", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysTotalhigh, sizeof(ccnsysTotalhigh), in)!=NULL){
			       printf("%s", ccnsysTotalhigh);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysTotalhigh,
			            sizeof( ccnsysTotalhigh ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysTotalhigh\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysFreehigh(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysBufferram = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysFreehigh[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysFreehigh", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysFreehigh, sizeof(ccnsysFreehigh), in)!=NULL){
			       printf("%s", ccnsysFreehigh);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysFreehigh,
			            sizeof( ccnsysFreehigh ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysFreehigh\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysMemunit(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysMemunit = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysMemunit[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysMemunit", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysMemunit, sizeof(ccnsysMemunit), in)!=NULL){
			       printf("%s", ccnsysMemunit);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysMemunit,
			            sizeof( ccnsysMemunit ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysMemunit\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ccnsysCharf(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

//	static int ccnsysMemunit = 7;

			FILE *in;
			extern FILE *popen();
			char ccnsysCharf[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccnSystem/ccnsysCharf", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ccnsysCharf, sizeof(ccnsysCharf), in)!=NULL){
			       printf("%s", ccnsysCharf);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ccnsysCharf,
			            sizeof( ccnsysCharf ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ccnsysCharf\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/contentItems ######################### */

int handle_ciAccessioned(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciAccessioned[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciAccessioned", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciAccessioned, sizeof(ciAccessioned), in)!=NULL){
			       printf("%s", ciAccessioned);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciAccessioned,
			            sizeof( ciAccessioned ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciAccessioned\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciDuplicate(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciDuplicate[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciDuplicate", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciDuplicate, sizeof(ciDuplicate), in)!=NULL){
			       printf("%s", ciDuplicate);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciDuplicate,
			            sizeof( ciDuplicate ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciDuplicate\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciSent(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciSent[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciSent", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciSent, sizeof(ciSent), in)!=NULL){
			       printf("%s", ciSent);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciSent,
			            sizeof( ciSent ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciSent\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciSparse(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciSparse[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciSparse", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciSparse, sizeof(ciSparse), in)!=NULL){
			       printf("%s", ciSparse);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciSparse,
			            sizeof( ciSparse ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciSparse\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciStale(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciStale[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciStale", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciStale, sizeof(ciStale), in)!=NULL){
			       printf("%s", ciStale);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciStale,
			            sizeof( ciStale ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciStale\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciStored(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciStored[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciStored", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciStored, sizeof(ciStored), in)!=NULL){
			       printf("%s", ciStored);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciStored,
			            sizeof( ciStored ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciStored\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciHost(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciHost[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciHost", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciHost, sizeof(ciHost), in)!=NULL){
			       printf("%s", ciHost);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciHost,
			            sizeof( ciHost ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciHost\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_ciTimestamp(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char ciTimestamp[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/contentItems/ciTimestamp", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(ciTimestamp, sizeof(ciTimestamp), in)!=NULL){
			       printf("%s", ciTimestamp);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &ciTimestamp,
			            sizeof( ciTimestamp ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ciTimestamp\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/interests ######################### */

int handle_iNames(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iNames[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iNames", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iNames, sizeof(iNames), in)!=NULL){
			       printf("%s", iNames);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iNames,
			            sizeof( iNames ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iNames\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_iNoted(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iNoted[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iNoted", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iNoted, sizeof(iNoted), in)!=NULL){
			       printf("%s", iNoted);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iNoted,
			            sizeof( iNoted ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iNoted\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_iPending(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iPending[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iPending", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iPending, sizeof(iPending), in)!=NULL){
			       printf("%s", iPending);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iPending,
			            sizeof( iPending ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iPending\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_iPropagating(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iPropagating[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iPropagating", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iPropagating, sizeof(iPropagating), in)!=NULL){
			       printf("%s", iPropagating);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iPropagating,
			            sizeof( iPropagating ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iPropagating\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_iHost(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iHost[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iHost", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iHost, sizeof(iHost), in)!=NULL){
			       printf("%s", iHost);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iHost,
			            sizeof( iHost ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iHost\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_iTimestamp(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char iTimestamp[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interests/iTimestamp", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(iTimestamp, sizeof(iTimestamp), in)!=NULL){
			       printf("%s", iTimestamp);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &iTimestamp,
			            sizeof( iTimestamp ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iTimestamp\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/interestTotals ######################### */

int handle_itAccepted(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itAccepted[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itAccepted", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itAccepted, sizeof(itAccepted), in)!=NULL){
			       printf("%s", itAccepted);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itAccepted,
			            sizeof( itAccepted ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itAccepted\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_itDropped(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itDropped[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itDropped", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itDropped, sizeof(itDropped), in)!=NULL){
			       printf("%s", itDropped);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itDropped,
			            sizeof( itDropped ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itDropped\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_itSent(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itSent[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itSent", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itSent, sizeof(itSent), in)!=NULL){
			       printf("%s", itSent);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itSent,
			            sizeof( itSent ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itSent\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_itStuffed(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itStuffed[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itStuffed", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itStuffed, sizeof(itStuffed), in)!=NULL){
			       printf("%s", itStuffed);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itStuffed,
			            sizeof( itStuffed ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itStuffed\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_itHost(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itHost[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itHost", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itHost, sizeof(itHost), in)!=NULL){
			       printf("%s", itHost);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itHost,
			            sizeof( itHost ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itHost\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_itTimestamp(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char itTimestamp[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/interestTotals/itTimestamp", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(itTimestamp, sizeof(itTimestamp), in)!=NULL){
			       printf("%s", itTimestamp);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &itTimestamp,
			            sizeof( itTimestamp ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_itTimestamp\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/faces ######################### */

int handle_fFace0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace0, sizeof(fFace0), in)!=NULL){
			       printf("%s", fFace0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace0,
			            sizeof( fFace0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags0, sizeof(fFlags0), in)!=NULL){
			       printf("%s", fFlags0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags0,
			            sizeof( fFlags0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal0, sizeof(fLocal0), in)!=NULL){
			       printf("%s", fLocal0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal0,
			            sizeof( fLocal0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending0, sizeof(fPending0), in)!=NULL){
			       printf("%s", fPending0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending0,
			            sizeof( fPending0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote0, sizeof(fRemote0), in)!=NULL){
			       printf("%s", fRemote0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote0,
			            sizeof( fRemote0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost0, sizeof(fHost0), in)!=NULL){
			       printf("%s", fHost0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost0,
			            sizeof( fHost0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp0, sizeof(fTimestamp0), in)!=NULL){
			       printf("%s", fTimestamp0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp0,
			            sizeof( fTimestamp0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace1, sizeof(fFace1), in)!=NULL){
			       printf("%s", fFace1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace1,
			            sizeof( fFace1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags1, sizeof(fFlags1), in)!=NULL){
			       printf("%s", fFlags1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags1,
			            sizeof( fFlags1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal1, sizeof(fLocal1), in)!=NULL){
			       printf("%s", fLocal1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal1,
			            sizeof( fLocal1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending1, sizeof(fPending1), in)!=NULL){
			       printf("%s", fPending1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending1,
			            sizeof( fPending1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote1, sizeof(fRemote1), in)!=NULL){
			       printf("%s", fRemote1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote1,
			            sizeof( fRemote1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost1, sizeof(fHost1), in)!=NULL){
			       printf("%s", fHost1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost1,
			            sizeof( fHost1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp1, sizeof(fTimestamp1), in)!=NULL){
			       printf("%s", fTimestamp1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp1,
			            sizeof( fTimestamp1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace2, sizeof(fFace2), in)!=NULL){
			       printf("%s", fFace2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace2,
			            sizeof( fFace2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags2, sizeof(fFlags2), in)!=NULL){
			       printf("%s", fFlags2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags2,
			            sizeof( fFlags2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal2, sizeof(fLocal2), in)!=NULL){
			       printf("%s", fLocal2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal2,
			            sizeof( fLocal2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending2, sizeof(fPending2), in)!=NULL){
			       printf("%s", fPending2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending2,
			            sizeof( fPending2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote2, sizeof(fRemote2), in)!=NULL){
			       printf("%s", fRemote2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote2,
			            sizeof( fRemote2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost2, sizeof(fHost2), in)!=NULL){
			       printf("%s", fHost2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost2,
			            sizeof( fHost2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp2, sizeof(fTimestamp2), in)!=NULL){
			       printf("%s", fTimestamp2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp2,
			            sizeof( fTimestamp2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace3, sizeof(fFace3), in)!=NULL){
			       printf("%s", fFace3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace3,
			            sizeof( fFace3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags3, sizeof(fFlags3), in)!=NULL){
			       printf("%s", fFlags3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags3,
			            sizeof( fFlags3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal3, sizeof(fLocal3), in)!=NULL){
			       printf("%s", fLocal3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal3,
			            sizeof( fLocal3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending3, sizeof(fPending3), in)!=NULL){
			       printf("%s", fPending3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending3,
			            sizeof( fPending3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote3, sizeof(fRemote3), in)!=NULL){
			       printf("%s", fRemote3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote3,
			            sizeof( fRemote3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost3, sizeof(fHost3), in)!=NULL){
			       printf("%s", fHost3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost3,
			            sizeof( fHost3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp3, sizeof(fTimestamp3), in)!=NULL){
			       printf("%s", fTimestamp3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp3,
			            sizeof( fTimestamp3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace4, sizeof(fFace4), in)!=NULL){
			       printf("%s", fFace4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace4,
			            sizeof( fFace4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags4, sizeof(fFlags4), in)!=NULL){
			       printf("%s", fFlags4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags4,
			            sizeof( fFlags4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal4, sizeof(fLocal4), in)!=NULL){
			       printf("%s", fLocal4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal4,
			            sizeof( fLocal4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending4, sizeof(fPending4), in)!=NULL){
			       printf("%s", fPending4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending4,
			            sizeof( fPending4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote4, sizeof(fRemote4), in)!=NULL){
			       printf("%s", fRemote4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote4,
			            sizeof( fRemote4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost4, sizeof(fHost4), in)!=NULL){
			       printf("%s", fHost4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost4,
			            sizeof( fHost4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp4, sizeof(fTimestamp4), in)!=NULL){
			       printf("%s", fTimestamp4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp4,
			            sizeof( fTimestamp4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace5, sizeof(fFace5), in)!=NULL){
			       printf("%s", fFace5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace5,
			            sizeof( fFace5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags5, sizeof(fFlags5), in)!=NULL){
			       printf("%s", fFlags5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags5,
			            sizeof( fFlags5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal5, sizeof(fLocal5), in)!=NULL){
			       printf("%s", fLocal5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal5,
			            sizeof( fLocal5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending5, sizeof(fPending5), in)!=NULL){
			       printf("%s", fPending5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending5,
			            sizeof( fPending5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote5, sizeof(fRemote5), in)!=NULL){
			       printf("%s", fRemote5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote5,
			            sizeof( fRemote5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost5, sizeof(fHost5), in)!=NULL){
			       printf("%s", fHost5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost5,
			            sizeof( fHost5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp5, sizeof(fTimestamp5), in)!=NULL){
			       printf("%s", fTimestamp5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp5,
			            sizeof( fTimestamp5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace6, sizeof(fFace6), in)!=NULL){
			       printf("%s", fFace6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace6,
			            sizeof( fFace6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags6, sizeof(fFlags6), in)!=NULL){
			       printf("%s", fFlags6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags6,
			            sizeof( fFlags6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal6, sizeof(fLocal6), in)!=NULL){
			       printf("%s", fLocal6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal6,
			            sizeof( fLocal6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending6, sizeof(fPending6), in)!=NULL){
			       printf("%s", fPending6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending6,
			            sizeof( fPending6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote6, sizeof(fRemote6), in)!=NULL){
			       printf("%s", fRemote6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote6,
			            sizeof( fRemote6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost6, sizeof(fHost6), in)!=NULL){
			       printf("%s", fHost6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost6,
			            sizeof( fHost6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp6, sizeof(fTimestamp6), in)!=NULL){
			       printf("%s", fTimestamp6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp6,
			            sizeof( fTimestamp6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace7, sizeof(fFace7), in)!=NULL){
			       printf("%s", fFace7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace7,
			            sizeof( fFace7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags7, sizeof(fFlags7), in)!=NULL){
			       printf("%s", fFlags7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags7,
			            sizeof( fFlags7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal7, sizeof(fLocal7), in)!=NULL){
			       printf("%s", fLocal7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal7,
			            sizeof( fLocal7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending7, sizeof(fPending7), in)!=NULL){
			       printf("%s", fPending7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending7,
			            sizeof( fPending7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote7, sizeof(fRemote7), in)!=NULL){
			       printf("%s", fRemote7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote7,
			            sizeof( fRemote7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost7, sizeof(fHost7), in)!=NULL){
			       printf("%s", fHost7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost7,
			            sizeof( fHost7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp7, sizeof(fTimestamp7), in)!=NULL){
			       printf("%s", fTimestamp7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp7,
			            sizeof( fTimestamp7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace8, sizeof(fFace8), in)!=NULL){
			       printf("%s", fFace8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace8,
			            sizeof( fFace8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags8, sizeof(fFlags8), in)!=NULL){
			       printf("%s", fFlags8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags8,
			            sizeof( fFlags8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal8, sizeof(fLocal8), in)!=NULL){
			       printf("%s", fLocal8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal8,
			            sizeof( fLocal8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending8, sizeof(fPending8), in)!=NULL){
			       printf("%s", fPending8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending8,
			            sizeof( fPending8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote8, sizeof(fRemote8), in)!=NULL){
			       printf("%s", fRemote8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote8,
			            sizeof( fRemote8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost8, sizeof(fHost8), in)!=NULL){
			       printf("%s", fHost8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost8,
			            sizeof( fHost8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp8, sizeof(fTimestamp8), in)!=NULL){
			       printf("%s", fTimestamp8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp8,
			            sizeof( fTimestamp8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace9, sizeof(fFace9), in)!=NULL){
			       printf("%s", fFace9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace9,
			            sizeof( fFace9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags9, sizeof(fFlags9), in)!=NULL){
			       printf("%s", fFlags9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags9,
			            sizeof( fFlags9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal9, sizeof(fLocal9), in)!=NULL){
			       printf("%s", fLocal9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal9,
			            sizeof( fLocal9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending9, sizeof(fPending9), in)!=NULL){
			       printf("%s", fPending9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending9,
			            sizeof( fPending9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote9, sizeof(fRemote9), in)!=NULL){
			       printf("%s", fRemote9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote9,
			            sizeof( fRemote9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost9, sizeof(fHost9), in)!=NULL){
			       printf("%s", fHost9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost9,
			            sizeof( fHost9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp9, sizeof(fTimestamp9), in)!=NULL){
			       printf("%s", fTimestamp9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp9,
			            sizeof( fTimestamp9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace10, sizeof(fFace10), in)!=NULL){
			       printf("%s", fFace10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace10,
			            sizeof( fFace10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags10, sizeof(fFlags10), in)!=NULL){
			       printf("%s", fFlags10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags10,
			            sizeof( fFlags10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal10, sizeof(fLocal10), in)!=NULL){
			       printf("%s", fLocal10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal10,
			            sizeof( fLocal10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending10, sizeof(fPending10), in)!=NULL){
			       printf("%s", fPending10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending10,
			            sizeof( fPending10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote10, sizeof(fRemote10), in)!=NULL){
			       printf("%s", fRemote10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote10,
			            sizeof( fRemote10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost10, sizeof(fHost10), in)!=NULL){
			       printf("%s", fHost10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost10,
			            sizeof( fHost10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp10, sizeof(fTimestamp10), in)!=NULL){
			       printf("%s", fTimestamp10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp10,
			            sizeof( fTimestamp10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace11, sizeof(fFace11), in)!=NULL){
			       printf("%s", fFace11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace11,
			            sizeof( fFace11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags11, sizeof(fFlags11), in)!=NULL){
			       printf("%s", fFlags11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags11,
			            sizeof( fFlags11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal11, sizeof(fLocal11), in)!=NULL){
			       printf("%s", fLocal11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal11,
			            sizeof( fLocal11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending11, sizeof(fPending11), in)!=NULL){
			       printf("%s", fPending11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending11,
			            sizeof( fPending11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote11, sizeof(fRemote11), in)!=NULL){
			       printf("%s", fRemote11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote11,
			            sizeof( fRemote11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost11, sizeof(fHost11), in)!=NULL){
			       printf("%s", fHost11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost11,
			            sizeof( fHost11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp11(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp11[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp11", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp11, sizeof(fTimestamp11), in)!=NULL){
			       printf("%s", fTimestamp11);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp11,
			            sizeof( fTimestamp11 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp11\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace12, sizeof(fFace12), in)!=NULL){
			       printf("%s", fFace12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace12,
			            sizeof( fFace12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags12, sizeof(fFlags12), in)!=NULL){
			       printf("%s", fFlags12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags12,
			            sizeof( fFlags12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal12, sizeof(fLocal12), in)!=NULL){
			       printf("%s", fLocal12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal12,
			            sizeof( fLocal12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending12, sizeof(fPending12), in)!=NULL){
			       printf("%s", fPending12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending12,
			            sizeof( fPending12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote12, sizeof(fRemote12), in)!=NULL){
			       printf("%s", fRemote12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote12,
			            sizeof( fRemote12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost12, sizeof(fHost12), in)!=NULL){
			       printf("%s", fHost12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost12,
			            sizeof( fHost12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp12(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp12[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp12", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp12, sizeof(fTimestamp12), in)!=NULL){
			       printf("%s", fTimestamp12);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp12,
			            sizeof( fTimestamp12 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp12\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFace13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFace13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFace13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFace13, sizeof(fFace13), in)!=NULL){
			       printf("%s", fFace13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFace13,
			            sizeof( fFace13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFace13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fFlags13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fFlags13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fFlags13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fFlags13, sizeof(fFlags13), in)!=NULL){
			       printf("%s", fFlags13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fFlags13,
			            sizeof( fFlags13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fFlags13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fLocal13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fLocal13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fLocal13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fLocal13, sizeof(fLocal13), in)!=NULL){
			       printf("%s", fLocal13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fLocal13,
			            sizeof( fLocal13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fLocal13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fPending13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fPending13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fPending13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fPending13, sizeof(fPending13), in)!=NULL){
			       printf("%s", fPending13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fPending13,
			            sizeof( fPending13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fPending13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fRemote13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fRemote13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fRemote13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fRemote13, sizeof(fRemote13), in)!=NULL){
			       printf("%s", fRemote13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fRemote13,
			            sizeof( fRemote13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fRemote13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fHost13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fHost13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fHost13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fHost13, sizeof(fHost13), in)!=NULL){
			       printf("%s", fHost13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fHost13,
			            sizeof( fHost13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fHost13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fTimestamp13(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fTimestamp13[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faces/fTimestamp13", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fTimestamp13, sizeof(fTimestamp13), in)!=NULL){
			       printf("%s", fTimestamp13);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fTimestamp13,
			            sizeof( fTimestamp13 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fTimestamp13\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/faceActivityRates ######################### */

int handle_farFace0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace0, sizeof(farFace0), in)!=NULL){
			       printf("%s", farFace0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace0,
			            sizeof( farFace0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn0, sizeof(farBytesIn0), in)!=NULL){
			       printf("%s", farBytesIn0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn0,
			            sizeof( farBytesIn0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut0, sizeof(farBytesOut0), in)!=NULL){
			       printf("%s", farBytesOut0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut0,
			            sizeof( farBytesOut0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData0, sizeof(farReceivedData0), in)!=NULL){
			       printf("%s", farReceivedData0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData0,
			            sizeof( farReceivedData0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData0, sizeof(farSentData0), in)!=NULL){
			       printf("%s", farSentData0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData0,
			            sizeof( farSentData0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived0, sizeof(farInterestsReceived0), in)!=NULL){
			       printf("%s", farInterestsReceived0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived0,
			            sizeof( farInterestsReceived0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent0, sizeof(farInterestsSent0), in)!=NULL){
			       printf("%s", farInterestsSent0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent0,
			            sizeof( farInterestsSent0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost0, sizeof(farHost0), in)!=NULL){
			       printf("%s", farHost0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost0,
			            sizeof( farHost0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp0, sizeof(farTimestamp0), in)!=NULL){
			       printf("%s", farTimestamp0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp0,
			            sizeof( farTimestamp0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace1, sizeof(farFace1), in)!=NULL){
			       printf("%s", farFace1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace1,
			            sizeof( farFace1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn1, sizeof(farBytesIn1), in)!=NULL){
			       printf("%s", farBytesIn1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn1,
			            sizeof( farBytesIn1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut1, sizeof(farBytesOut1), in)!=NULL){
			       printf("%s", farBytesOut1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut1,
			            sizeof( farBytesOut1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData1, sizeof(farReceivedData1), in)!=NULL){
			       printf("%s", farReceivedData1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData1,
			            sizeof( farReceivedData1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData1, sizeof(farSentData1), in)!=NULL){
			       printf("%s", farSentData1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData1,
			            sizeof( farSentData1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived1, sizeof(farInterestsReceived1), in)!=NULL){
			       printf("%s", farInterestsReceived1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived1,
			            sizeof( farInterestsReceived1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent1, sizeof(farInterestsSent1), in)!=NULL){
			       printf("%s", farInterestsSent1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent1,
			            sizeof( farInterestsSent1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost1, sizeof(farHost1), in)!=NULL){
			       printf("%s", farHost1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost1,
			            sizeof( farHost1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp1, sizeof(farTimestamp1), in)!=NULL){
			       printf("%s", farTimestamp1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp1,
			            sizeof( farTimestamp1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace2, sizeof(farFace2), in)!=NULL){
			       printf("%s", farFace2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace2,
			            sizeof( farFace2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn2, sizeof(farBytesIn2), in)!=NULL){
			       printf("%s", farBytesIn2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn2,
			            sizeof( farBytesIn2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut2, sizeof(farBytesOut2), in)!=NULL){
			       printf("%s", farBytesOut2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut2,
			            sizeof( farBytesOut2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData2, sizeof(farReceivedData2), in)!=NULL){
			       printf("%s", farReceivedData2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData2,
			            sizeof( farReceivedData2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData2, sizeof(farSentData2), in)!=NULL){
			       printf("%s", farSentData2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData2,
			            sizeof( farSentData2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived2, sizeof(farInterestsReceived2), in)!=NULL){
			       printf("%s", farInterestsReceived2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived2,
			            sizeof( farInterestsReceived2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent2, sizeof(farInterestsSent2), in)!=NULL){
			       printf("%s", farInterestsSent2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent2,
			            sizeof( farInterestsSent2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost2, sizeof(farHost2), in)!=NULL){
			       printf("%s", farHost2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost2,
			            sizeof( farHost2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp2, sizeof(farTimestamp2), in)!=NULL){
			       printf("%s", farTimestamp2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp2,
			            sizeof( farTimestamp2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace3, sizeof(farFace3), in)!=NULL){
			       printf("%s", farFace3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace3,
			            sizeof( farFace3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn3, sizeof(farBytesIn3), in)!=NULL){
			       printf("%s", farBytesIn3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn3,
			            sizeof( farBytesIn3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut3, sizeof(farBytesOut3), in)!=NULL){
			       printf("%s", farBytesOut3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut3,
			            sizeof( farBytesOut3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData3, sizeof(farReceivedData3), in)!=NULL){
			       printf("%s", farReceivedData3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData3,
			            sizeof( farReceivedData3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData3, sizeof(farSentData3), in)!=NULL){
			       printf("%s", farSentData3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData3,
			            sizeof( farSentData3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived3, sizeof(farInterestsReceived3), in)!=NULL){
			       printf("%s", farInterestsReceived3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived3,
			            sizeof( farInterestsReceived3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent3, sizeof(farInterestsSent3), in)!=NULL){
			       printf("%s", farInterestsSent3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent3,
			            sizeof( farInterestsSent3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost3, sizeof(farHost3), in)!=NULL){
			       printf("%s", farHost3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost3,
			            sizeof( farHost3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp3, sizeof(farTimestamp3), in)!=NULL){
			       printf("%s", farTimestamp3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp3,
			            sizeof( farTimestamp3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace4, sizeof(farFace4), in)!=NULL){
			       printf("%s", farFace4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace4,
			            sizeof( farFace4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn4, sizeof(farBytesIn4), in)!=NULL){
			       printf("%s", farBytesIn4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn4,
			            sizeof( farBytesIn4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut4, sizeof(farBytesOut4), in)!=NULL){
			       printf("%s", farBytesOut4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut4,
			            sizeof( farBytesOut4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData4, sizeof(farReceivedData4), in)!=NULL){
			       printf("%s", farReceivedData4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData4,
			            sizeof( farReceivedData4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData4, sizeof(farSentData4), in)!=NULL){
			       printf("%s", farSentData4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData4,
			            sizeof( farSentData4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived4, sizeof(farInterestsReceived4), in)!=NULL){
			       printf("%s", farInterestsReceived4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived4,
			            sizeof( farInterestsReceived4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent4, sizeof(farInterestsSent4), in)!=NULL){
			       printf("%s", farInterestsSent4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent4,
			            sizeof( farInterestsSent4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost4, sizeof(farHost4), in)!=NULL){
			       printf("%s", farHost4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost4,
			            sizeof( farHost4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp4, sizeof(farTimestamp4), in)!=NULL){
			       printf("%s", farTimestamp4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp4,
			            sizeof( farTimestamp4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace5, sizeof(farFace5), in)!=NULL){
			       printf("%s", farFace5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace5,
			            sizeof( farFace5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn5, sizeof(farBytesIn5), in)!=NULL){
			       printf("%s", farBytesIn5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn5,
			            sizeof( farBytesIn5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut5, sizeof(farBytesOut5), in)!=NULL){
			       printf("%s", farBytesOut5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut5,
			            sizeof( farBytesOut5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData5, sizeof(farReceivedData5), in)!=NULL){
			       printf("%s", farReceivedData5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData5,
			            sizeof( farReceivedData5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData5, sizeof(farSentData5), in)!=NULL){
			       printf("%s", farSentData5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData5,
			            sizeof( farSentData5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived5, sizeof(farInterestsReceived5), in)!=NULL){
			       printf("%s", farInterestsReceived5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived5,
			            sizeof( farInterestsReceived5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent5, sizeof(farInterestsSent5), in)!=NULL){
			       printf("%s", farInterestsSent5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent5,
			            sizeof( farInterestsSent5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost5, sizeof(farHost5), in)!=NULL){
			       printf("%s", farHost5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost5,
			            sizeof( farHost5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp5, sizeof(farTimestamp5), in)!=NULL){
			       printf("%s", farTimestamp5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp5,
			            sizeof( farTimestamp5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace6, sizeof(farFace6), in)!=NULL){
			       printf("%s", farFace6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace6,
			            sizeof( farFace6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn6, sizeof(farBytesIn6), in)!=NULL){
			       printf("%s", farBytesIn6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn6,
			            sizeof( farBytesIn6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut6, sizeof(farBytesOut6), in)!=NULL){
			       printf("%s", farBytesOut6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut6,
			            sizeof( farBytesOut6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData6, sizeof(farReceivedData6), in)!=NULL){
			       printf("%s", farReceivedData6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData6,
			            sizeof( farReceivedData6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData6, sizeof(farSentData6), in)!=NULL){
			       printf("%s", farSentData6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData6,
			            sizeof( farSentData6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived6, sizeof(farInterestsReceived6), in)!=NULL){
			       printf("%s", farInterestsReceived6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived6,
			            sizeof( farInterestsReceived6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent6, sizeof(farInterestsSent6), in)!=NULL){
			       printf("%s", farInterestsSent6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent6,
			            sizeof( farInterestsSent6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost6, sizeof(farHost6), in)!=NULL){
			       printf("%s", farHost6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost6,
			            sizeof( farHost6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp6, sizeof(farTimestamp6), in)!=NULL){
			       printf("%s", farTimestamp6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp6,
			            sizeof( farTimestamp6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace7, sizeof(farFace7), in)!=NULL){
			       printf("%s", farFace7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace7,
			            sizeof( farFace7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn7, sizeof(farBytesIn7), in)!=NULL){
			       printf("%s", farBytesIn7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn7,
			            sizeof( farBytesIn7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut7, sizeof(farBytesOut7), in)!=NULL){
			       printf("%s", farBytesOut7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut7,
			            sizeof( farBytesOut7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData7, sizeof(farReceivedData7), in)!=NULL){
			       printf("%s", farReceivedData7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData7,
			            sizeof( farReceivedData7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData7, sizeof(farSentData7), in)!=NULL){
			       printf("%s", farSentData7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData7,
			            sizeof( farSentData7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived7, sizeof(farInterestsReceived7), in)!=NULL){
			       printf("%s", farInterestsReceived7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived7,
			            sizeof( farInterestsReceived7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent7, sizeof(farInterestsSent7), in)!=NULL){
			       printf("%s", farInterestsSent7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent7,
			            sizeof( farInterestsSent7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost7, sizeof(farHost7), in)!=NULL){
			       printf("%s", farHost7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost7,
			            sizeof( farHost7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp7, sizeof(farTimestamp7), in)!=NULL){
			       printf("%s", farTimestamp7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp7,
			            sizeof( farTimestamp7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farFace8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farFace8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farFace8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farFace8, sizeof(farFace8), in)!=NULL){
			       printf("%s", farFace8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farFace8,
			            sizeof( farFace8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farFace8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesIn8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesIn8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesIn8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesIn8, sizeof(farBytesIn8), in)!=NULL){
			       printf("%s", farBytesIn8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesIn8,
			            sizeof( farBytesIn8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesIn8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farBytesOut8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farBytesOut8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farBytesOut8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farBytesOut8, sizeof(farBytesOut8), in)!=NULL){
			       printf("%s", farBytesOut8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farBytesOut8,
			            sizeof( farBytesOut8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farBytesOut8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farReceivedData8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farReceivedData8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farReceivedData8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farReceivedData8, sizeof(farReceivedData8), in)!=NULL){
			       printf("%s", farReceivedData8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farReceivedData8,
			            sizeof( farReceivedData8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farReceivedData8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farSentData8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farSentData8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farSentData8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farSentData8, sizeof(farSentData8), in)!=NULL){
			       printf("%s", farSentData8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farSentData8,
			            sizeof( farSentData8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farSentData8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsReceived8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsReceived8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsReceived8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsReceived8, sizeof(farInterestsReceived8), in)!=NULL){
			       printf("%s", farInterestsReceived8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsReceived8,
			            sizeof( farInterestsReceived8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsReceived8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farInterestsSent8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farInterestsSent8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farInterestsSent8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farInterestsSent8, sizeof(farInterestsSent8), in)!=NULL){
			       printf("%s", farInterestsSent8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farInterestsSent8,
			            sizeof( farInterestsSent8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farInterestsSent8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farHost8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farHost8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farHost8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farHost8, sizeof(farHost8), in)!=NULL){
			       printf("%s", farHost8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farHost8,
			            sizeof( farHost8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farHost8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_farTimestamp8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char farTimestamp8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/faceActivityRates/farTimestamp8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(farTimestamp8, sizeof(farTimestamp8), in)!=NULL){
			       printf("%s", farTimestamp8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &farTimestamp8,
			            sizeof( farTimestamp8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_farTimestamp8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ######################### Handle ccndStatus/forwarding ######################### */

int handle_fwFace0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace0, sizeof(fwFace0), in)!=NULL){
			       printf("%s", fwFace0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace0,
			            sizeof( fwFace0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags0, sizeof(fwFlags0), in)!=NULL){
			       printf("%s", fwFlags0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags0,
			            sizeof( fwFlags0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath0, sizeof(fwPath0), in)!=NULL){
			       printf("%s", fwPath0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath0,
			            sizeof( fwPath0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires0, sizeof(fwExpires0), in)!=NULL){
			       printf("%s", fwExpires0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires0,
			            sizeof( fwExpires0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost0, sizeof(fwHost0), in)!=NULL){
			       printf("%s", fwHost0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost0,
			            sizeof( fwHost0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp0, sizeof(fwTimestamp0), in)!=NULL){
			       printf("%s", fwTimestamp0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp0,
			            sizeof( fwTimestamp0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace1, sizeof(fwFace1), in)!=NULL){
			       printf("%s", fwFace1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace1,
			            sizeof( fwFace1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags1, sizeof(fwFlags1), in)!=NULL){
			       printf("%s", fwFlags1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags1,
			            sizeof( fwFlags1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath1, sizeof(fwPath1), in)!=NULL){
			       printf("%s", fwPath1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath1,
			            sizeof( fwPath1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires1, sizeof(fwExpires1), in)!=NULL){
			       printf("%s", fwExpires1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires1,
			            sizeof( fwExpires1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost1, sizeof(fwHost1), in)!=NULL){
			       printf("%s", fwHost1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost1,
			            sizeof( fwHost1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp1(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp1[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp1", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp1, sizeof(fwTimestamp1), in)!=NULL){
			       printf("%s", fwTimestamp1);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp1,
			            sizeof( fwTimestamp1 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace2, sizeof(fwFace2), in)!=NULL){
			       printf("%s", fwFace2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace2,
			            sizeof( fwFace2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags2, sizeof(fwFlags2), in)!=NULL){
			       printf("%s", fwFlags2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags2,
			            sizeof( fwFlags2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath2, sizeof(fwPath2), in)!=NULL){
			       printf("%s", fwPath2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath2,
			            sizeof( fwPath2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires2, sizeof(fwExpires2), in)!=NULL){
			       printf("%s", fwExpires2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires2,
			            sizeof( fwExpires2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost2, sizeof(fwHost2), in)!=NULL){
			       printf("%s", fwHost2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost2,
			            sizeof( fwHost2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp2(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp2[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp2", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp2, sizeof(fwTimestamp2), in)!=NULL){
			       printf("%s", fwTimestamp2);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp2,
			            sizeof( fwTimestamp2 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace3, sizeof(fwFace3), in)!=NULL){
			       printf("%s", fwFace3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace3,
			            sizeof( fwFace3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags3, sizeof(fwFlags3), in)!=NULL){
			       printf("%s", fwFlags3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags3,
			            sizeof( fwFlags3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath3, sizeof(fwPath3), in)!=NULL){
			       printf("%s", fwPath3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath3,
			            sizeof( fwPath3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires3, sizeof(fwExpires3), in)!=NULL){
			       printf("%s", fwExpires3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires3,
			            sizeof( fwExpires3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost3, sizeof(fwHost3), in)!=NULL){
			       printf("%s", fwHost3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost3,
			            sizeof( fwHost3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp3(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp3[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp3", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp3, sizeof(fwTimestamp3), in)!=NULL){
			       printf("%s", fwTimestamp3);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp3,
			            sizeof( fwTimestamp3 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp3\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace4, sizeof(fwFace4), in)!=NULL){
			       printf("%s", fwFace4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace4,
			            sizeof( fwFace4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags4, sizeof(fwFlags4), in)!=NULL){
			       printf("%s", fwFlags4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags4,
			            sizeof( fwFlags4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath4, sizeof(fwPath4), in)!=NULL){
			       printf("%s", fwPath4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath4,
			            sizeof( fwPath4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires4, sizeof(fwExpires4), in)!=NULL){
			       printf("%s", fwExpires4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires4,
			            sizeof( fwExpires4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost4, sizeof(fwHost4), in)!=NULL){
			       printf("%s", fwHost4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost4,
			            sizeof( fwHost4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp4(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp4[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp4", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp4, sizeof(fwTimestamp4), in)!=NULL){
			       printf("%s", fwTimestamp4);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp4,
			            sizeof( fwTimestamp4 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp4\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace5, sizeof(fwFace5), in)!=NULL){
			       printf("%s", fwFace5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace5,
			            sizeof( fwFace5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags5, sizeof(fwFlags5), in)!=NULL){
			       printf("%s", fwFlags5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags5,
			            sizeof( fwFlags5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath5, sizeof(fwPath5), in)!=NULL){
			       printf("%s", fwPath5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath5,
			            sizeof( fwPath5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires5, sizeof(fwExpires5), in)!=NULL){
			       printf("%s", fwExpires5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires5,
			            sizeof( fwExpires5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost5, sizeof(fwHost5), in)!=NULL){
			       printf("%s", fwHost5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost5,
			            sizeof( fwHost5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp5(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp5[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp5", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp5, sizeof(fwTimestamp5), in)!=NULL){
			       printf("%s", fwTimestamp5);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp5,
			            sizeof( fwTimestamp5 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp5\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace6, sizeof(fwFace6), in)!=NULL){
			       printf("%s", fwFace6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace6,
			            sizeof( fwFace6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags6, sizeof(fwFlags6), in)!=NULL){
			       printf("%s", fwFlags6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags6,
			            sizeof( fwFlags6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath6, sizeof(fwPath6), in)!=NULL){
			       printf("%s", fwPath6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath6,
			            sizeof( fwPath6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires6, sizeof(fwExpires6), in)!=NULL){
			       printf("%s", fwExpires6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires6,
			            sizeof( fwExpires6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost6, sizeof(fwHost6), in)!=NULL){
			       printf("%s", fwHost6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost6,
			            sizeof( fwHost6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp6(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp6[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp6", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp6, sizeof(fwTimestamp6), in)!=NULL){
			       printf("%s", fwTimestamp6);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp6,
			            sizeof( fwTimestamp6 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp6\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace7, sizeof(fwFace7), in)!=NULL){
			       printf("%s", fwFace7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace7,
			            sizeof( fwFace7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags7, sizeof(fwFlags7), in)!=NULL){
			       printf("%s", fwFlags7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags7,
			            sizeof( fwFlags7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath7, sizeof(fwPath7), in)!=NULL){
			       printf("%s", fwPath7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath7,
			            sizeof( fwPath7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires7, sizeof(fwExpires7), in)!=NULL){
			       printf("%s", fwExpires7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires7,
			            sizeof( fwExpires7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost7, sizeof(fwHost7), in)!=NULL){
			       printf("%s", fwHost7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost7,
			            sizeof( fwHost7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp7(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp7[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp7", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp7, sizeof(fwTimestamp7), in)!=NULL){
			       printf("%s", fwTimestamp7);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp7,
			            sizeof( fwTimestamp7 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp7\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace8, sizeof(fwFace8), in)!=NULL){
			       printf("%s", fwFace8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace8,
			            sizeof( fwFace8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags8, sizeof(fwFlags8), in)!=NULL){
			       printf("%s", fwFlags8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags8,
			            sizeof( fwFlags8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath8, sizeof(fwPath8), in)!=NULL){
			       printf("%s", fwPath8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath8,
			            sizeof( fwPath8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires8, sizeof(fwExpires8), in)!=NULL){
			       printf("%s", fwExpires8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires8,
			            sizeof( fwExpires8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost8, sizeof(fwHost8), in)!=NULL){
			       printf("%s", fwHost8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost8,
			            sizeof( fwHost8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp8(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp8[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp8", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp8, sizeof(fwTimestamp8), in)!=NULL){
			       printf("%s", fwTimestamp8);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp8,
			            sizeof( fwTimestamp8 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp8\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace9, sizeof(fwFace9), in)!=NULL){
			       printf("%s", fwFace9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace9,
			            sizeof( fwFace9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags9, sizeof(fwFlags9), in)!=NULL){
			       printf("%s", fwFlags9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags9,
			            sizeof( fwFlags9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath9, sizeof(fwPath9), in)!=NULL){
			       printf("%s", fwPath9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath9,
			            sizeof( fwPath9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires9, sizeof(fwExpires9), in)!=NULL){
			       printf("%s", fwExpires9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires9,
			            sizeof( fwExpires9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost9, sizeof(fwHost9), in)!=NULL){
			       printf("%s", fwHost9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost9,
			            sizeof( fwHost9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp9(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp9[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp9", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp9, sizeof(fwTimestamp9), in)!=NULL){
			       printf("%s", fwTimestamp9);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp9,
			            sizeof( fwTimestamp9 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp9\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFace10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFace10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFace10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFace10, sizeof(fwFace10), in)!=NULL){
			       printf("%s", fwFace10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFace10,
			            sizeof( fwFace10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFace10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwFlags10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwFlags10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwFlags10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwFlags10, sizeof(fwFlags10), in)!=NULL){
			       printf("%s", fwFlags10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwFlags10,
			            sizeof( fwFlags10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwFlags10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwPath10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath10, sizeof(fwPath10), in)!=NULL){
			       printf("%s", fwPath10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath10,
			            sizeof( fwPath10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwExpires10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwExpires10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwExpires10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwExpires10, sizeof(fwExpires10), in)!=NULL){
			       printf("%s", fwExpires10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwExpires10,
			            sizeof( fwExpires10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwExpires10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwHost10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwHost10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwHost10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwHost10, sizeof(fwHost10), in)!=NULL){
			       printf("%s", fwHost10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwHost10,
			            sizeof( fwHost10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwHost10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_fwTimestamp10(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwTimestamp10[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwTimestamp10", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwTimestamp10, sizeof(fwTimestamp10), in)!=NULL){
			       printf("%s", fwTimestamp10);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwTimestamp10,
			            sizeof( fwTimestamp10 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwTimestamp10\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


